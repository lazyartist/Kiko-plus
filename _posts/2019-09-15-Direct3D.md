---
layout: post
title: "Direct3D"
description: ""
date: 2019-09-15 19:00:00+09:00
tags: [Direct3D]
comments: true
share: true
---

[TOC]



## COM(Component Object Model)

- 응용 프로그램 이진 인터페이스
- 프로그램이나 시스템을 이루는 컴포넌트들이 상호 통신할 수 있도록 하는 메커니즘
  - 서로 다른 프로그램들이 서로 통신할 수 있도록 하는 명세
- 컴포넌트란
  - .ocx, .dll, .exe를 확장자로 갖는 실행 가능한 바이너리 파일
- 특징
  - 언어 독립성
    - 서로 다른 언어로 작성된 컴포넌트들이 COM을 지원하는 툴로 만들어졋다면 마치 동일한 개발 도구로 생성한 프로그램 모듈처럼 상호 통신할 수 있다.
  - Binary Standard
    - 다른 플랫폼으로 작성된 프로그램의 소스코드가 없이 binary 파일만 있어도 사용할 수 있다.
  - Version Control
    - 새로운 기능을 모듈에 추가할 수 있다.
    - 새로운 기능과 이전 기능을 클라이언트 요청에 따라 동시에 제공할 수 있다.
  - Location Transparency
    - 컴포넌트가 물리적 위치에 관계없이 다른 컴포넌트 혹은 컴포넌트 클라이언트에 의해 사용될 수 있다.
    - In-process
      - .dll, .ocx
      - 컴포넌트 클라이언트의 메모리 영역으로 로드되어 사용됨
    - Out-of-process
      - .exe
      - 컴포넌트 클라이언트와 동일한 머신에서 수행
    - Out-of-machine(네트워크를 통한 리모트 머신)
      - .exe
      - 컴포넌트 클라이언트와 네트워크로 연결된 다른 머신에서 수행
- Interface
  - COM이 제공하는 기능
  - COM 컴포넌트는 하나 이상의 인터페이스를 제공해야한다.
  - COM 객체가 제공하는 기능을 기술한 것
    - 바이너리 파일로 배포되는 COM 컴포넌트가 자신이 제공하는 기능을 이를 사용하려는 프로그램에 알려줄 수 있는 방법이 필요하기 때문



## Direct3D와 다른 시스템 컴포넌트와의 관계도


<svg xmlns="http://www.w3.org/2000/svg" width="662" height="284.1111145019531" style="
        width:662px;
        height:284.1111145019531px;
        background: #FFF;
        fill: none;
">
        <svg xmlns="http://www.w3.org/2000/svg"><g><defs><pattern id=".2845496072733278" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="lightgray" stroke-width="0.5"/></pattern></defs><rect width="100%" height="100%" fill="url(#.2845496072733278)" stroke="lightgray" stroke-width="0.5"/></g></svg>
        <svg xmlns="http://www.w3.org/2000/svg" class="role-diagram-draw-area"><g class="shapes-region" style="stroke: black; fill: none;"><g/></g><g><g class="connection-group"><g class="arrow-line"><path class="connection real" stroke-dasharray="" d="  M261,81 L261,38" style="stroke: rgb(0, 0, 0); stroke-width: 1; fill: none;"/><g stroke="#000" transform="matrix(3.061616997868383e-16,1,-1,3.061616997868383e-16,261,36)" style="stroke: rgb(0, 0, 0); stroke-width: 1;"><path d=" M10.93,-3.29 Q4.96,-0.45 0,0 Q4.96,0.45 10.93,3.29"/></g></g></g><g class="connection-group"><g class="arrow-line"><path class="connection real" stroke-dasharray="" d="  M192.12,139 L243.23,104.13" style="stroke: rgb(0, 0, 0); stroke-width: 1; fill: none;"/><g stroke="#000" transform="matrix(-0.8259999280643188,0.5636702217056886,-0.5636702217056886,-0.8259999280643188,244.87931034482756,103)" style="stroke: rgb(0, 0, 0); stroke-width: 1;"><path d=" M10.93,-3.29 Q4.96,-0.45 0,0 Q4.96,0.45 10.93,3.29"/></g></g></g><g class="connection-group"><g class="arrow-line"><path class="connection real" stroke-dasharray="" d="  M367.51,194 L273.93,104.38" style="stroke: rgb(0, 0, 0); stroke-width: 1; fill: none;"/><g stroke="#000" transform="matrix(0.7222432592616973,0.6916391215446396,-0.6916391215446396,0.7222432592616973,272.4867256637168,103)" style="stroke: rgb(0, 0, 0); stroke-width: 1;"><path d=" M10.93,-3.29 Q4.96,-0.45 0,0 Q4.96,0.45 10.93,3.29"/></g></g></g><g class="connection-group"><g class="arrow-line"><path class="connection real" stroke-dasharray="" d="  M338.4,194 L218.53,161.52" style="stroke: rgb(0, 0, 0); stroke-width: 1; fill: none;"/><g stroke="#000" transform="matrix(0.9651993018659998,0.261515406195097,-0.261515406195097,0.9651993018659998,216.6,161)" style="stroke: rgb(0, 0, 0); stroke-width: 1;"><path d=" M10.93,-3.29 Q4.96,-0.45 0,0 Q4.96,0.45 10.93,3.29"/></g></g></g><g class="connection-group"><g class="arrow-line"><path class="connection real" stroke-dasharray="" d="  M389.11,194 L469.54,106.47" style="stroke: rgb(0, 0, 0); stroke-width: 1; fill: none;"/><g stroke="#000" transform="matrix(-0.6766189820945451,0.7363333165553095,-0.7363333165553095,-0.6766189820945451,470.8918918918918,105)" style="stroke: rgb(0, 0, 0); stroke-width: 1;"><path d=" M10.93,-3.29 Q4.96,-0.45 0,0 Q4.96,0.45 10.93,3.29"/></g></g></g><g class="connection-group"><g class="arrow-line"><path class="connection real" stroke-dasharray="" d="  M481.33,83 L482.61,40" style="stroke: rgb(0, 0, 0); stroke-width: 1; fill: none;"/><g stroke="#000" transform="matrix(-0.0298406997386805,0.9995546671588833,-0.9995546671588833,-0.0298406997386805,482.6716417910448,38)" style="stroke: rgb(0, 0, 0); stroke-width: 1;"><path d=" M10.93,-3.29 Q4.96,-0.45 0,0 Q4.96,0.45 10.93,3.29"/></g></g></g><g class="connection-group"><g class="arrow-line"><path class="connection real" stroke-dasharray="" d="  M378.23,241 L378.72,218" style="stroke: rgb(0, 0, 0); stroke-width: 1; fill: none;"/><g stroke="#000" transform="matrix(-0.02129140789487423,0.9997733122812661,-0.9997733122812661,-0.02129140789487423,378.76595744680856,216)" style="stroke: rgb(0, 0, 0); stroke-width: 1;"><path d=" M10.93,-3.29 Q4.96,-0.45 0,0 Q4.96,0.45 10.93,3.29"/></g></g></g></g><g><g><rect rx="0" ry="0" x="419" y="16" width="128" height="22" style="stroke: rgb(0, 0, 0); stroke-width: 1; fill: none;"/></g><g><rect rx="0" ry="0" x="197" y="14" width="128" height="22" style="stroke: rgb(0, 0, 0); stroke-width: 1; fill: none;"/></g><g><rect rx="0" ry="0" x="214" y="81" width="94" height="22" style="stroke: rgb(0, 0, 0); stroke-width: 1; fill: none;"/></g><g><rect rx="0" ry="0" x="132.5" y="139" width="87" height="22" style="stroke: rgb(0, 0, 0); stroke-width: 1; fill: none;"/></g><g><rect rx="0" ry="0" x="281" y="194" width="196" height="22" style="stroke: rgb(0, 0, 0); stroke-width: 1; fill: none;"/></g><g><rect rx="0" ry="0" x="463.5" y="83" width="35" height="22" style="stroke: rgb(0, 0, 0); stroke-width: 1; fill: none;"/></g><g><rect rx="0" ry="0" x="309.5" y="241" width="137" height="22" style="stroke: rgb(0, 0, 0); stroke-width: 1; fill: none;"/></g></g><!-- react-empty: 11581 --></svg>
        <svg xmlns="http://www.w3.org/2000/svg" width="660" height="282.1111145019531" style="width:660px;height:282.1111145019531px;font-family:Asana-Math, Asana;background:#FFF;"><g><g><text x="201.37847900390625" y="16.555557250976562" style="white-space:pre;stroke:none;fill:rgb(0, 0, 0);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(0, 0, 0);">Win32 Application</text></g></g><g><g><text x="423.37847900390625" y="18.555557250976562" style="white-space:pre;stroke:none;fill:rgb(0, 0, 0);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(0, 0, 0);">Win32 Application</text></g></g><g><g><text x="201.37847900390625" y="16.555557250976562" style="white-space:pre;stroke:none;fill:rgb(0, 0, 0);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(0, 0, 0);">Win32 Application</text></g></g><g><g><text x="218.06597900390625" y="83.55557250976562" style="white-space:pre;stroke:none;fill:rgb(0, 0, 0);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(0, 0, 0);">Direct3D API</text></g></g><g><g><text x="136.67709350585938" y="141.55557250976562" style="white-space:pre;stroke:none;fill:rgb(0, 0, 0);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(0, 0, 0);">HAL Device</text></g></g><g><g><text x="284.8125" y="196.55557250976562" style="white-space:pre;stroke:none;fill:rgb(0, 0, 0);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(0, 0, 0);">Device Driver Interface(DDI)</text></g></g><g><g><text x="467.6632080078125" y="85.55557250976562" style="white-space:pre;stroke:none;fill:rgb(0, 0, 0);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(0, 0, 0);">GDI</text></g></g><g><g><text x="313.39239501953125" y="243.55557250976562" style="white-space:pre;stroke:none;fill:rgb(0, 0, 0);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(0, 0, 0);">Graphics Hardware</text></g></g></svg>
</svg>


- HAL(Hardware Abstraction Layer)
  - 하드웨어 추상화 계층
  - 컴퓨터의 물리적인 하드웨어와 컴퓨터에서 실행되는 소프트웨어 사이의 추상화 계층
  - 하드웨어의 차이를 숨겨서 응용 프로그램이 작동할 수 있는 일관된 플랫폼을 제공
  - 하드웨어 가속을 사용하므로 빠르지만 특정 하드웨어에서는 안돌아갈 수 있다.
- Reference Device
  - 하드웨어 가속을 하지 않는다.
  - 범용적이지만 느리다.
- GDI(Graphics Device Interface)
  - 응용프로그램에서 그래픽 관련 하드웨어를 사용할 수 있게 한다.
  - Bitmap, Brush, Color, Font, Pen, Video Display, Printer, ...
- DDI(Device Driver Interface)

  - 하드웨어 설치 후 운영체제에 설치하는 소프트웨어
  - 드라이버



## Windows10에서 DirectX SDK 설치

### DirectX SDK 9 설치

- 설치 안하고 사용하려 했으나 예제를 따라하기 힘들어 그냥 설치한다.
  - https://www.microsoft.com/en-us/download/details.aspx?id=6812
- 설치하니 프로그램 목록에 다음 것들이 추가됐다.
  - Microsoft DirectX SDK (June 2010)
  - Microsoft Visual C++ 2008 Redistributable - x86 9.0.30729.17
  - Microsoft Visual C++ 2010 Redistributable - x86 10.0.30319
- 헤더파일과 라이브러리를 프로젝트에 추가한다.
  - 
  - 



- 2012 11월 Windows8.0부터 Windows SDK에 DirectX SDK가 포함되어 따로 설치할 필요가 없다.
- 단, 일부 기능이 미지원될 수 있다.
- Windows10에서 DirceX9 SDK를 따로 설치하지 않고 DirectX9을 사용할 수 있지만 기존의 라이브러리중 사용할 수 없는 것이 있다.
  - d3dx9math.h
    - 여기에서 사용된 D3DXVECTOR3 등의 구조체는 DirectXMath.h에 있는 구조체로 대체하여 사용해야한다.
    - 여기에 대응되는 목록이 있다.
      - Working with D3DXMath
      - https://docs.microsoft.com/en-us/windows/win32/dxmath/pg-xnamath-migration-d3dx

### DirectX9를 설치한 경우

- DirectX 설치 디렉터리의 include 디렉터리 경로를 프로젝트 포함 디렉터리에 추가
- DirectX 설치 디렉터리의 lib 디렉터리 경로를 프로젝트 라이브러리 디렉터리에 추가
- 프로젝트 설정 > 링커 > 추가 종속성에 다음 추가
  - dxguid.lib
  - d3d9.lib
  - d3dx9.lib









## Direct3D 초기화 및 생성

```cpp
//Direct3D 9버전의 헤더 추가
#include <d3d9.h>
//Direct3D 9 라이브러리 추가
//#pragma comment는 프로젝트 속성에서 lib를 포함하지 않아도 사용할 수 있게 한다.
//첫번째 인자는 등록할 확장명, 두번째 인자는 파일 이름
#pragma comment (lib, "d3d9.lib")


//DirectX 시스템 객체 포인터, COM interface이다.
LPDIRECT3D9 g_pD3DInterface;
//DirectX 디바이스 객체(실제 화면을 출력하는 역할)
//디바이스 인터페이스, 그래픽 드라이버, 비디오 카드에 대한 정보를 가지고 있다.
//렌더링을 위해 사용한다.
LPDIRECT3DDEVICE9 g_pD3DDevice;


	//g_pD3DInterface 
	//Direct3D COM interface를 생성
	//Direct3D 9C 버전에서는 32를 리턴한다.
	if ((g_pD3DInterface = Direct3DCreate9(D3D_SDK_VERSION)) == nullptr) {
		return E_FAIL;
	}
	//g_pD3DInterface 디바이스 생성에 필요한 파라미터를 전달하고 그래픽 장치에 대한 정보를 받아오는 구조체
	D3DPRESENT_PARAMETERS sD3DParam;
	//sD3DParam의 메모리를 초기화한다.
	//참고로 sD3DParam의 기본값은 대부분 0이기 때문에 0으로 초기화하고 필요한 값만 변경하면 된다.
	ZeroMemory(&sD3DParam, sizeof(sD3DParam));
	//true:창, false:전체화면
	sD3DParam.Windowed = true;
	//화면 버퍼링 방식 지정
	//D3DSWAPEFFECT_DISCARD: 플립방식으로 백버퍼의 값을 보존하지 않는 방식. 따라서 플리핑 시 주소만 교환하므로 빠르다.
	//D3DSWAPEFFECT_FLIP: 플립방식으로 백버퍼의 값을 보존하는 방식. 플리핑 시 이전 백 버퍼의 내용을 다음 백버퍼에 복사하고 프론트 버퍼로 지정되므로 느리다. 백버퍼가 여러개일 수 있다.
	//D3DSWAPEEFECT_COPY: 백버퍼를 고정하는 방식으로 프론트 버퍼에 백 버퍼의 픽셀을 복사한다.
	sD3DParam.SwapEffect = D3DSWAPEFFECT_DISCARD;
	//현재 윈도우와 동일한 색상 정보를 갖는 백버퍼를 사용
	sD3DParam.BackBufferFormat = D3DFMT_UNKNOWN;
	//Direct3D를 사용할 윈도우 핸들
	sD3DParam.hDeviceWindow = g_hWnd;
	//Direct3D 디바이스 객체를 생성
	if (FAILED(g_pD3DInterface->CreateDevice(D3DADAPTER_DEFAULT,
		//그래픽 디바이스 타입을 정한다.
		//그래픽 가속을 위해 HAL(Hardware Abstraction Layer)를 사용한다.
		D3DDEVTYPE_HAL,
		//윈도우 핸들
		g_hWnd,
		//D3DCREATE_SOFTWARE_VERTEXPROCESSING: 3D 계산을 소프트웨어로 한다.
		//D3DCREATE_MIXED_VERTEXPROCESSING: 소프트웨어와 하드웨어 분할처리
		//D3DCREATE_HARDWARE_VERTEXPROCESSING: 하드웨어에서 처리
		D3DCREATE_SOFTWARE_VERTEXPROCESSING,
		//D3DPRESENT_PARAMETERS의 포인터
		&sD3DParam,
		//LPDIRECT3DDEVICE9의 포인터(이중포인터)
		&g_pD3DDevice))) {
		return E_FAIL;
	};

	//render
	//백버퍼를 지정된 색으로 지운다(비운다)
	//첫번재, 두번째 매개변수는 사용되지 않는다.
	//세번째는 백버퍼를 비워야하므로 D3DCLEAR_TARGET을 지정, D3DCLEAR_TARGET: 백버퍼를 지우겠다는 뜻.
	//네번재는 D3DCOLOR_XRGB 매크로를 통해 색을 지정, XRGB는 Alpha값을 안쓴다는 뜻. 255가 1.0이다.
	g_pD3DDevice->Clear(0, nullptr, D3DCLEAR_TARGET, D3DCOLOR_XRGB(0, 40, 100), 1.0f, 0);
	//g_pD3DInterface에서 비디오 메모리를 컨트롤 하기 위해 잠금을 해지한다.
	//용도1. g_pD3DInterface 메모리 컨트롤
	//용도2. BeginScene()을 호출하면 메모리에 단독으로 액세스 할 수 있기 때문에 비디오 RAM 버퍼를 잠금 또는 해지할 때 사용
	if (SUCCEEDED(g_pD3DDevice->BeginScene())) {
		//여기서 화면을 그린다.

		//BeginScene()로 잠금해지된 비디오 메모리를 잠근다.
		g_pD3DDevice->EndScene();
		//백버퍼를 프론트버퍼로 교환(플리핑)한다.
		g_pD3DDevice->Present(nullptr, nullptr, nullptr, nullptr);
	};



	//release g_pD3DInterface
	//디바이스를 먼저 해제한다.
	if(g_pD3DDevice != nullptr) g_pD3DDevice->Release();
	if (g_pD3DInterface != nullptr) g_pD3DInterface->Release();
```







## Direct3D 구조

### Direct3D 그래픽 파이프라인 구조

- 입력 조립기
- 정점 셰이더
- 덮개 셰이더
- 테셀레이터
- 영역 셰이더
- 기하 셰이더
  - 스트림 출력
- 래스터화
- 픽셀 셰이더
- 출력 병합기



## 벡터

### 벡터 구조체

- D3DVECTOR
- x, y, z값만 가지는 단순한 구조체

### 벡터 구조체 확장

- D3DXVECTOR3
- D3DVECTOR를 상속하여 연산자 오버로딩 등 추가 기능을 더한 구조체

### 벡터의 연산

- 헤더: D3dx9math.h
- 라이브러리: D3dx9.lib

### 벡터의 합

- D3DXVec3Add()
- D3DXVECTOR3의 operator+를 사용해도 된다.

### 벡터의 차

- D3DXVec3Subtract()
- D3DXVECTOR3의 operator-를 사용해도 된다.

### 벡터의 크기

- D3DXVec3Length()

### 벡터의 크기 변환

- D3DXVec3Scale()

### 벡터의 정규화

- D3DXVecNormalize()

### 벡터의 내적

- D3DXVec3Dot()

### 벡터의 외적

- 두 벡터로 이루어진 평면이 앞면인지 뒷면인지 판단
  - 평면이 법선 벡터와 카메라 시선 벡터의 내적이 양수이면 뒷면 음수이면 앞면
- 빛의 방향과 법선 벡터 사이각의 정도에 따라 빛의 양을 결정
  - 내적의 절대값(|-1~1|)을 빛의 양에 곱해준다.
- 외적은 연산순서가 바뀌면 방향이 다른 벡터가 나오므로 교환법칙이 성립하지 않는다.
- D3DXVec3Cross()



## 정점

### 정점 

- 공간 상의 한점
- 선분에서는 각 끝에 위치한 점
- 삼각형에서는 각 꼭지점

### 정점 포맷

- d3d에서 정점을 나타내기 위한 자료구조
- FVF(flexible vertex format)
  - 각 프로그램에 맞게 정점 포맷을 정의할 수 있도록 유연성을 제공한다.
  - 필요로하는 정점 포맷을 선택하여 조합할 수 있다.

#### FVF의 요소들

| 이름                          | 한글 이름          | 자료구조             | 자료형                          | 설명                                                         |
| ----------------------------- | ------------------ | -------------------- | ------------------------------- | ------------------------------------------------------------ |
| Position                      | 정점의 좌표        | x, y, z              | float3                          | 정점의 3차원 x, y, z 값                                      |
| RHW(Reciprocal Homogeneous W) | -                  | RHW                  | float                           | 동차 좌표계의 W값(이미 변환된 정점에만 사용하는 옵션)        |
| Blending Weight Data          | 결합가중치         | 1st-5th Blend Weight | -                               | 블렌딩값(스키닝에 사용)                                      |
| Vertex Normal                 | 정점의 법선벡터    | x, y, z              | float3                          | 정점의 법선벡터(광원처리에 사용)                             |
| Vertex Point Size             | 정점의 포인트 크기 | size                 | float                           | 정점의 포인트 크기                                           |
| Diffuse Color                 | 확산광 색          | r, g, b, a           | DWORD                           | RGBA(r, g, b, a) 매크로값, 정점의 확산광 색을 나타냄         |
| Specular Color                | 반사광 색          | r, g, b, a           | DWORD                           | RGBA(r, g, b, a) 매크로값, 정점의 반사광을 나타냄            |
| Texture Coordinate Set 1~8    | 텍스처 좌표        | 1, 2, 3 or 4         | float, float2, float3 or float4 | 텍스처 좌표값, Direct3D는 8개의 텍스처를 동시에 겹쳐서 사용할 수 있다.<br />(예, 첫 번째 값을 diffuse 맵정보로, 두 번째 값을 법선맵 정보로 설정해서 사용하는 식) |

> RHW
>
> - 현재의 정점을 2D 좌표처럼 사용
> - RHW가 설정되면 현재의 정점 좌표가 3D 변환인 월드, 뷰, 프로젝션 변환이 적용된 최종 좌표로 판단하므로 x, y 좌표만 참조하여 그대로 화면에 출력한다.
> - 일반적으로 w의 값은 1.0로 고정하여 사용



#### 정점 포맷 만들기

- FVF로 정점을 정의하고 Flexible vertex format bits로 각 자료형의 역할이 무엇인지 정의한다.

```cpp
//정점 구조체 정의
struct SVertex {
	float x, y, z, rhw;
	DWORD color;
};
//정점 구조체 멤버의 역할 정의
#define D3DFVF_SVertex (D3DFVF_XYZRHW | D3DFVF_DIFFUSE)
```



### 정점 3개로 삼각형 만들기

```cpp
SVertex sVertices[3] = {
    {100.0f, 200.0f, 0.0f, 1.0f, 0xffff0000},
    {200.0f, 100.0f, 0.0f, 1.0f, 0xff00ff00},
    {300.0f, 200.0f, 0.0f, 1.0f, 0xff0000ff}
};
```



### Direct3D의 좌표계

- 왼손 좌표계


<svg xmlns="http://www.w3.org/2000/svg" width="662" height="302" style="
        width:662px;
        height:302px;
        background: #FFF;
        fill: none;
">
        <svg xmlns="http://www.w3.org/2000/svg"><g><defs><pattern id=".9514236866772476" width="10" height="10" patternUnits="userSpaceOnUse"><path d="M 10 0 L 0 0 0 10" fill="none" stroke="lightgray" stroke-width="0.5"/></pattern></defs><rect width="100%" height="100%" fill="url(#.9514236866772476)" stroke="lightgray" stroke-width="0.5"/></g></svg>
        <svg xmlns="http://www.w3.org/2000/svg" class="role-diagram-draw-area"><g class="shapes-region" style="stroke: black; fill: none;"><g class="composite-shape"><path class="real" d=" M332,171 L367,211 L297,211 Z" style="stroke-width: 1; stroke: rgb(0, 0, 0); fill: none;"/></g><g class="composite-shape"><path class="real" d=" M453.5,217.35 C453.5,181.62 417.91,152.66 374,152.66 L374,128.81 C417.91,128.81 453.5,157.77 453.5,193.5" style="stroke-width: 1; stroke: rgb(74, 144, 226); fill: rgb(255, 255, 255);"/><path class="real" d=" M453.5,193.5 C453.5,220.03 433.88,242.83 405.8,252.82 L405.8,244.87 L374,270.13 L405.8,284.62 L405.8,276.67 C433.88,266.68 453.5,243.88 453.5,217.35 M453.5,193.5 L453.5,217.35" style="stroke-width: 1; stroke: rgb(74, 144, 226); fill: rgb(255, 255, 255);"/></g><g class="arrow-line"><path class="connection real" stroke-dasharray="" d="  M297,211 L297,168.81" style="stroke: rgb(74, 144, 226); stroke-width: 1; fill: none;"/><g stroke="none" fill="rgba(74,144,226,1)" transform="matrix(3.061616997868383e-16,1,-1,3.061616997868383e-16,297,166.8055419921875)" style="stroke: none; fill: rgb(74, 144, 226); stroke-width: 1;"><path d=" M8.93,-4.29 L0,0 L8.93,4.29 Z"/></g><g stroke="rgba(74,144,226,1)" fill="rgba(74,144,226,1)" transform="matrix(-1.8369701987210297e-16,-1,1,-1.8369701987210297e-16,297,211)" style="stroke: rgb(74, 144, 226); fill: rgb(74, 144, 226); stroke-width: 1;"><circle cx="0" cy="0" r="3.35"/></g></g><g class="arrow-line"><path class="connection real" stroke-dasharray="" d="  M332,171 L332,128.81" style="stroke: rgb(74, 144, 226); stroke-width: 1; fill: none;"/><g stroke="none" fill="rgba(74,144,226,1)" transform="matrix(3.061616997868383e-16,1,-1,3.061616997868383e-16,332,126.8055419921875)" style="stroke: none; fill: rgb(74, 144, 226); stroke-width: 1;"><path d=" M8.93,-4.29 L0,0 L8.93,4.29 Z"/></g><g stroke="rgba(74,144,226,1)" transform="matrix(-1.8369701987210297e-16,-1,1,-1.8369701987210297e-16,332,171)" style="stroke: rgb(74, 144, 226); stroke-width: 1; fill: rgb(74, 144, 226);" fill="rgba(74,144,226,1)"><circle cx="0" cy="0" r="3.35"/></g></g><g class="arrow-line"><path class="connection real" stroke-dasharray="" d="  M367,211 L367,168.81" style="stroke: rgb(74, 144, 226); stroke-width: 1; fill: none;"/><g stroke="none" fill="rgba(74,144,226,1)" transform="matrix(3.061616997868383e-16,1,-1,3.061616997868383e-16,367,166.8055419921875)" style="stroke: none; fill: rgb(74, 144, 226); stroke-width: 1;"><path d=" M8.93,-4.29 L0,0 L8.93,4.29 Z"/></g><g stroke="rgba(74,144,226,1)" fill="rgba(74,144,226,1)" transform="matrix(-1.8369701987210297e-16,-1,1,-1.8369701987210297e-16,367,210.99999999999994)" style="stroke: rgb(74, 144, 226); fill: rgb(74, 144, 226); stroke-width: 1;"><circle cx="0" cy="0" r="3.35"/></g></g><g class="composite-shape"><path class="real" d=" M214.5,218.95 C214.5,182.78 248.3,153.46 290,153.46 L290,130.81 C248.3,130.81 214.5,160.13 214.5,196.3" style="stroke-width: 1; stroke: rgb(208, 2, 27); fill: rgb(255, 255, 255);"/><path class="real" d=" M214.5,196.3 C214.5,223.16 233.13,246.24 259.8,256.35 L259.8,248.8 L290,273.13 L259.8,286.55 L259.8,279 C233.13,268.89 214.5,245.81 214.5,218.95 M214.5,196.3 L214.5,218.95" style="stroke-width: 1; stroke: rgb(208, 2, 27); fill: rgb(255, 255, 255);"/></g><g class="arrow-line"><path class="connection real" stroke-dasharray="" d="  M297,213.35 L297,242.81" style="stroke: rgb(208, 2, 27); stroke-width: 1; fill: none;"/><g stroke="none" fill="rgba(208,2,27,1)" transform="matrix(-1.8369701987210297e-16,-1,1,-1.8369701987210297e-16,297,244.80554199218744)" style="stroke: none; fill: rgb(208, 2, 27); stroke-width: 1;"><path d=" M8.93,-4.29 L0,0 L8.93,4.29 Z"/></g><g stroke="rgba(208,2,27,1)" transform="matrix(6.123233995736766e-17,1,-1,6.123233995736766e-17,297,211)" style="stroke: rgb(208, 2, 27); stroke-width: 1;"><circle cx="0" cy="0" r="3.35"/></g></g><g class="arrow-line"><path class="connection real" stroke-dasharray="" d="  M332,173.35 L332,204.81" style="stroke: rgb(208, 2, 27); stroke-width: 1; fill: none;"/><g stroke="none" fill="rgba(208,2,27,1)" transform="matrix(-1.8369701987210297e-16,-1,1,-1.8369701987210297e-16,332,206.80554199218744)" style="stroke: none; fill: rgb(208, 2, 27); stroke-width: 1;"><path d=" M8.93,-4.29 L0,0 L8.93,4.29 Z"/></g><g stroke="rgba(208,2,27,1)" transform="matrix(6.123233995736766e-17,1,-1,6.123233995736766e-17,332,171)" style="stroke: rgb(208, 2, 27); stroke-width: 1;"><circle cx="0" cy="0" r="3.35"/></g></g><g class="arrow-line"><path class="connection real" stroke-dasharray="" d="  M367,213.35 L367,244.81" style="stroke: rgb(208, 2, 27); stroke-width: 1; fill: none;"/><g stroke="none" fill="rgba(208,2,27,1)" transform="matrix(-1.8369701987210297e-16,-1,1,-1.8369701987210297e-16,367,246.80554199218744)" style="stroke: none; fill: rgb(208, 2, 27); stroke-width: 1;"><path d=" M8.93,-4.29 L0,0 L8.93,4.29 Z"/></g><g stroke="rgba(208,2,27,1)" transform="matrix(6.123233995736766e-17,1,-1,6.123233995736766e-17,367,211)" style="stroke: rgb(208, 2, 27); stroke-width: 1;"><circle cx="0" cy="0" r="3.35"/></g></g><g/></g><g/><g/><!-- react-empty: 723 --></svg>
        <svg xmlns="http://www.w3.org/2000/svg" width="660" height="300" style="width:660px;height:300px;font-family:Asana-Math, Asana;background:#FFF;"><g><g><text x="202.1978759765625" y="9" style="white-space:pre;stroke:none;fill:rgb(0, 0, 0);font-size:21.6px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(0, 0, 0);">왼손 좌표계 법선벡터 방향</text></g></g><g><g><text x="279.625" y="201.5555419921875" style="white-space:pre;stroke:none;fill:rgb(0, 0, 0);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(0, 0, 0);">a</text></g></g><g><g><text x="316.625" y="158.5555419921875" style="white-space:pre;stroke:none;fill:rgb(0, 0, 0);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(0, 0, 0);">b</text></g></g><g><g><text x="374.625" y="199.5555419921875" style="white-space:pre;stroke:none;fill:rgb(0, 0, 0);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(0, 0, 0);">c</text></g></g><g><g><text x="471.5833740234375" y="163.5555419921875" style="white-space:pre;stroke:none;fill:rgb(74, 144, 226);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(74, 144, 226);">시계방향(ClockWise)</text></g></g><g><g><text x="492.8160400390625" y="186.5555419921875" style="white-space:pre;stroke:none;fill:rgb(74, 144, 226);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(74, 144, 226);">a → b → c→ a</text></g></g><g><g><text x="4.40277099609375" y="171.5555419921875" style="white-space:pre;stroke:none;fill:rgb(208, 2, 27);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(208, 2, 27);">반시계방향(CounterClockWise)</text></g></g><g><g><text x="57.732666015625" y="194.5555419921875" style="white-space:pre;stroke:none;fill:rgb(208, 2, 27);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(208, 2, 27);">a → c → b → a</text></g></g><g><g><text x="23.32989501953125" y="220.5555419921875" style="white-space:pre;stroke:none;fill:rgb(208, 2, 27);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(208, 2, 27);">법선벡터가 아래로 향한다</text></g></g><g><g><text x="461.74658203125" y="217.5555419921875" style="white-space:pre;stroke:none;fill:rgb(74, 144, 226);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(74, 144, 226);">법선벡터가 위로 향한다.</text></g></g><g><g><text x="72.98614501953125" y="55.77777099609375" style="white-space:pre;stroke:none;fill:rgb(0, 0, 0);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(0, 0, 0);">1. 왼손을 엄지척 모양으로 만든다.</text></g><g><text x="72.98614501953125" y="73.5555419921875" style="white-space:pre;stroke:none;fill:rgb(0, 0, 0);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(0, 0, 0);">2. 그려지는 방향과 왼손의 검지, 중지, 약지, 새끼 손가락이 감싸쥔 방향을 맞춘다.</text></g><g><text x="72.98614501953125" y="91.33331298828125" style="white-space:pre;stroke:none;fill:rgb(0, 0, 0);font-size:15px;font-family:Arial, Helvetica, sans-serif;font-weight:400;font-style:normal;dominant-baseline:text-before-edge;text-decoration:none solid rgb(0, 0, 0);">3. 엄지척한 엄지의 방향이 법선의 방향이다.</text></g></g></svg>
</svg>



### 정점 데이터의 순서

- 정점 데이터는 시계방향으로 만든다.
- Direct3D는 왼손 좌표계이므로 왼손으로 감싸쥐었을 때 왼손의 검지부터 새끼까지의 손가락이 가리키는 방향으로 버텍스를 그려야 법선 벡터가 엄지손가락 쪽으로 향하게 된다.



### 정점 버퍼 생성

- 출력할 정점을 저장하는 연속적인 메모리 버퍼
- 정점 버퍼는 비디오 메모리에 정점을 저장하기 때문에 시스템 메모리보다 휠씬 빠르다.
- CreateVertexBuffer()

```cpp
	//버텍스버퍼 생성
	LPDIRECT3DVERTEXBUFFER9 pVB;//버텍스버퍼의 인터페이스
	pD3DFramework->pD3DDevice->CreateVertexBuffer(
		sizeof(SVertex) * sizeof(sVertices) / sizeof(SVertex),//버텍스크기*개수
		D3DUSAGE_WRITEONLY,//리소스 사용법을 지정(D3DUSAGE_WRITEONLY:어플에서 버텍스버퍼의 쓰기 조작만 수행함을 지정)
		D3DFVF_SVertex,//버텍스데이터 사용법
		D3DPOOL_DEFAULT,//리소스버퍼를 저장할 시스템, 비디오 메모리를 지정(D3DPOOL_DEFAULT:최적의 메모리를 자동 선택)
		&pVB,//반환된 버텍스버퍼를 받을 포인터
		nullptr//사용하지 않는 변수, nullptr
	);
	//버텍스버퍼에 버텍스를 저장하기 위해 잠금
	//Lock을 하면 다른 자원이 접근할 수 없게되고 정점을 저장할 메모리 포인터를 반환한다.
	void *pVertices;//버텍스를 저장할 메모리의 시작 주소를 받을 변수
	pVB->Lock(0, 0, (void**)&pVertices, 0);
	memcpy(pVertices, sVertices, sizeof(sVertices));//버텍스버퍼에 버텍스를 메모리 복사
	pVB->Unlock();//잠금을 해제
```



### 정점을 화면에 출력하여 도형 그리기

- d3dDevice->BeginScene()과 d3dDevice->EndScene() 사이에 정점의 렌더링 코드를 작성한다.
- 정점 데이터 스트림
  - http://telnet.or.kr/directx/graphics/programmingguide/gettingstarted/rendering/renderingprimitives/vertexdatastreams.htm

![](https://raw.githubusercontent.com/lazyartist/blog/master/images/vertexdatastream.gif)

```cpp
	//버텍스 출력
	//1. 버텍스버퍼와 버텍스 포맷을 D3D 디바이스에 알려준다. 출력할 버텍스버퍼를 출력 스트림과 연결한다.
	pD3DFramework->pD3DDevice->SetStreamSource(
		0,//0으로 지정
		pVertexBuffer, //버텍스버퍼
		0, //메모리시작 위치
		sizeof(SVertex) //버텍스 크기
	);
	//2. D3D에 정점 셰이더 정보를 지정, 대부분 FVF만 지정한다.
	pD3DFramework->pD3DDevice->SetFVF(D3DFVF_SVertex);
	//3. 기하 정보를 출력하기 위한 DrawPrimitive() 함수 호출
	//DrawIndexedPrimitive(), DrawPrimitiveUP(), DrawIndexedPrimitiveUP()등이 있고
	//DrawIndexedPrimitive(), DrawIndexedPrimitiveUP()함수가 게임개발에 많이 사용된다.
	//DrawIndexedPrimitive()함수가 가장 빠르다.
	pD3DFramework->pD3DDevice->DrawPrimitive(
		D3DPT_TRIANGLESTRIP,
		0, //출력을 시작할 버텍스 인덱스
		1 //출력할 개수, 첫번째 파라미터 D3DPRIMITIVETYPE에 영향을 받는다.
	);
```



![](https://raw.githubusercontent.com/lazyartist/blog/master/images/direct3d_first_triangle.PNG)



## 행렬

### 행렬 구조체

#### D3DMATRIX

- 4x4 구조체
- d3d9type.h

#### D3DXMATRIX, XMMATRIX

- D3DMATRIX를 상속한 클래스
- 연산자 오버로딩 제공
- d3dx9math.h

#### 단위행렬(Identity Matrix) 함수

##### D3DXMatrixIdentity, XMMatrixIdentity

- 단위행렬을 생성한다.

```cpp
	printTitle("행렬과 단위행렬의 곱");
	{
		XMMATRIX matMatrix = {
			{11, 12, 13, 14},
			{21, 22, 23, 24},
			{31, 32, 33, 34},
			{41, 42, 43, 44},
		};
		//단위행렬
		XMMATRIX matIdentity = XMMatrixIdentity();
		//행렬과 단위행렬의 곱 방법1
		XMMATRIX matResult = matMatrix * matIdentity;
		//행렬과 단위행렬의 곱 방법2
		matResult = XMMatrixMultiply(matMatrix, matIdentity);
		//출력
		printMatrix("matMatrix", matMatrix);
		printMatrix("matIdentity", matIdentity);
		printMatrix("matResult", matResult);
		/*
		- matMatrix -
		11.0    12.0    13.0    14.0
		21.0    22.0    23.0    24.0
		31.0    32.0    33.0    34.0
		41.0    42.0    43.0    44.0
		- matIdentity -
		1.0     0.0     0.0     0.0
		0.0     1.0     0.0     0.0
		0.0     0.0     1.0     0.0
		0.0     0.0     0.0     1.0
		- matResult -
		11.0    12.0    13.0    14.0
		21.0    22.0    23.0    24.0
		31.0    32.0    33.0    34.0
		41.0    42.0    43.0    44.0
		*/
	}
```



#### 전치행렬(Transposed Matrix) 함수

##### D3DXMatrixTranspose(), XMMatrixTranspose

- 주어진 행렬의 전치행렬을 구한다.

```cpp
	printTitle("전치행렬");
	{
		XMMATRIX matMatrix = {
			{11, 12, 13, 14},
			{21, 22, 23, 24},
			{31, 32, 33, 34},
			{41, 42, 43, 44},
		};
		//전치행렬
		XMMATRIX matTranspose = XMMatrixTranspose(matMatrix);
		printMatrix("matMatrix", matMatrix);
		printMatrix("matTranspose", matTranspose);
		/*
		- matMatrix -
		11.0    12.0    13.0    14.0
		21.0    22.0    23.0    24.0
		31.0    32.0    33.0    34.0
		41.0    42.0    43.0    44.0
		- matTranspose -
		11.0    21.0    31.0    41.0
		12.0    22.0    32.0    42.0
		13.0    23.0    33.0    43.0
		14.0    24.0    34.0    44.0
		*/
		//전치행렬을 다시 전치행렬로 만들기
		XMMATRIX matResult = XMMatrixTranspose(matTranspose);
		printMatrix("matResult", matResult);
		/*
		- matResult -
		11.0    12.0    13.0    14.0
		21.0    22.0    23.0    24.0
		31.0    32.0    33.0    34.0
		41.0    42.0    43.0    44.0
		*/
	}
```



#### 역행렬(Inverse Matrix)

##### D3DXMatrixInverse(), XMMatrixInverse

- 주어진 행렬의 역행력을 구한다.
- 판별식의 값을 받을 수 있다.

#### 회전행렬

##### D3DXMatrixRotationX, XMMatrixRotationX

- X축을 기준으로 회전하는 행렬을 구한다.

```cpp
	printTitle("역행렬");
	{
		XMMATRIX matMatrix;
		//회전행렬
		XMMATRIX matRotation = XMMatrixRotationX(0.3f);
		//행렬식값(0이면 역행렬이 존재하지 않고 0이외의 값이면 역행렬이 존재한다)
		XMVECTOR fDeterminant;
		//역행렬(회전행렬은 항상 역행렬이 존재)
		XMMATRIX matInverse = XMMatrixInverse(&fDeterminant, matRotation);
		printMatrix("matRotation", matRotation);
		printMatrix("matInverse", matInverse);
		printf_s("- fDeterminant : %f\n", fDeterminant.vector4_f32[0]);
		/*
		- matRotation -
		1.0     0.0     0.0     0.0
		0.0     1.0     0.3     0.0
		0.0     -0.3    1.0     0.0
		0.0     0.0     0.0     1.0
		- matInverse -
		1.0     -0.0    0.0     0.0
		0.0     1.0     -0.3    0.0
		0.0     0.3     1.0     0.0
		0.0     0.0     0.0     1.0
		- fDeterminant : 1.000000
		*/
		//회전행렬과 역행렬의 곱 = 단위행렬
		XMMATRIX matResult = XMMatrixMultiply(matRotation, matInverse);
		printMatrix("matResult", matResult);
		/*
		- matResult -
		1.0     0.0     0.0     0.0
		0.0     1.0     0.0     0.0
		0.0     0.0     1.0     0.0
		0.0     0.0     0.0     1.0
		*/
	}
```



### 라디안과 호도값 변환 매크로 함수

- D3DXToDegree(radian), XMConvertToDegrees
  - 라디안을 호도값으로 변환
- D3DXToRadian(degree), XMConvertToRadians
  - 호도값을 라디안으로 변환

```cpp
		printf_s("%f\n", XMConvertToRadians(90) );
		//1.570796
		printf_s("%f\n", XMConvertToDegrees(3.14) );
		//179.908737
```



### 선형변환

#### 이동행렬

- D3DXMatrixTranslation
- XMMatrixTranslation

```cpp
		XMMATRIX matTranslation = XMMatrixTranslation(10, 20, 30);
		printMatrix("matTranslation", matTranslation);
		/*
		1.0     0.0     0.0     0.0
		0.0     1.0     0.0     0.0
		0.0     0.0     1.0     0.0
		10.0    20.0    30.0    1.0
		*/
```



#### 크기행렬

- D3DXMatrixScaling
- XMMatrixScaling

```cpp
		XMMATRIX matScaling = XMMatrixScaling(0.5, 0.5, 0.5);
		printMatrix("matScaling", matScaling);
		/*
		0.5     0.0     0.0     0.0
		0.0     0.5     0.0     0.0
		0.0     0.0     0.5     0.0
		0.0     0.0     0.0     1.0
		*/
```



#### 회전행렬

##### 회전 행렬 함수

- D3DXMatrixRotationX, D3DXMatrixRotationY, D3DXMatrixRotationZ
- XMMatrixRotationX, XMMatrixRotationY, XMMatrixRotationZ

```cpp
		XMMATRIX matRotationX = XMMatrixRotationX(PI);
		printMatrix("matRotationX", matRotationX);
		/*
		1.0     0.0     0.0     0.0
		0.0     -1.0    0.0     0.0
		0.0     -0.0    -1.0    0.0
		0.0     0.0     0.0     1.0
		*/
```

##### x, y, z 축 회전이 적용된 행렬 함수

- D3DXMatrixRotationYawPitchRoll, XMMatrixRotationRollPitchYaw
  - 각 축에 대한 회전행렬을 다음 순서로 곱하여 반환한다.
    - Z * X * Y

```cpp
		XMMATRIX matRotationRollPitchYaw = XMMatrixRotationRollPitchYaw(PI, PI, PI);
		printMatrix("matRotationRollPitchYaw", matRotationRollPitchYaw);
		/*
		1.0     0.0     -0.0    0.0
		-0.0    1.0     -0.0    0.0
		0.0     0.0     1.0     0.0
		0.0     0.0     0.0     1.0
		*/
```

##### 임의의 축을 중심으로 한 회전 행렬 함수

- 임의의 축을 중심으로 시계방향으로 회전한 행렬을 구한다.
- D3DXMatrixRotationAxis, XMMatrixRotationAxis

```cpp
		XMMATRIX matRotationAxis = XMMatrixRotationAxis({1.0, 0, 0,0}, PI);
		printMatrix("matRotationAxis", matRotationAxis);
		/*
		1.0     0.0     0.0     0.0
		0.0     -1.0    0.0     0.0
		0.0     0.0     -1.0    0.0
		0.0     0.0     0.0     1.0
		*/
```

#### 이동과 회전, 확대/축소 행렬의 결합 순서

- S * R * T
- 크기행렬 * 회전행렬(z->x->y) * 이동 행렬

```cpp
		XMMATRIX matComposite = XMMatrixScaling(0.5, 0.5, 0.5)
			* XMMatrixRotationRollPitchYaw(PI, PI, PI)
			* XMMatrixTranslation(10, 20, 30);
		printMatrix("matComposite", matComposite);
		/*
		0.5     0.0     -0.0    0.0
		-0.0    0.5     -0.0    0.0
		0.0     0.0     0.5     0.0
		10.0    20.0    30.0    1.0
		*/
```



### 쿼터니온(사원수, Quaternion)

- 임의의 축을 기준으로 회전 행렬을 구해주는 수학도구
- 일반 회전 행렬에 비해 계산량이 적다
- 메모리를 적게 차지함
- 짐벌락(Gimbal Lock) 현상이 없음
- 단점
  - 직관적인 이해가 어렵다.



#### 쿼터니온 데이터 구조

- x, y, z는 회전축, w는 회전값(라디안)
- 회전 방향은 반시계(CCW)방향
- D3DXQUATERNION, XMVECTOR



#### 쿼터니온 연산

$$
Q=q_1 \cdot q_2
$$

- 행렬 곱셈과 다르게 뒤의 회전이 먼저 적용된다.
  - q2 회전을 먼저 적용하고 q1 회전을 적용
- 교환법칙 성립 안됨



##### 회전 행렬을 쿼터니온으로 만드는 함수

- D3DXQuaternionRotationMatrix, XMQuaternionRotationMatrix

```cpp
	printTitle("회전 행렬을 쿼터니온으로 만드는 함수");
	{
		XMMATRIX matRotation = XMMatrixRotationX(PI);
		printMatrix("matRotation", matRotation);
		/*
		1.0     0.0     0.0     0.0
		0.0     -1.0    0.0     0.0
		0.0     -0.0    -1.0    0.0
		0.0     0.0     0.0     1.0
		*/
		XMVECTOR vQuaternion = XMQuaternionRotationMatrix(matRotation);
		printVector("vQuaternion", vQuaternion);
		/*
		1.0     0.0     0.0     0.0
		*/
	}
```



##### yaw, pitch, roll에 의한 쿼터니온을 만드는 함수

- D3DXQuaternionRotationYawPitchRoll, XMQuaternionRotationRollPitchYaw

```cpp
	printTitle("yaw, pitch, roll에 의한 쿼터니온을 만드는 함수");
	{
		XMVECTOR vQuaternion = XMQuaternionRotationRollPitchYaw(PI, PI, PI);
		printVector("vQuaternion", vQuaternion);
		/*
		-0.0    0.0     0.0     1.0
		*/
	}
```

##### 임의의 축에 대해서 회전한 쿼터니온을 구하는 함수

- D3DXQuaternionRotationAxis, XMQuaternionRotationAxis
- 회전은 시계방향(CW)

```cpp
	printTitle("임의의 축에 대해서 회전한 쿼터니온을 구하는 함수");
	{
		XMVECTOR vQuaternion = XMQuaternionRotationAxis({ 1.0, 0, 0, 0 }, PI);
		printVector("vQuaternion", vQuaternion);
		/*
		1.0     0.0     0.0     -0.0
		*/
	}
```

##### 쿼터니온으로부터 회전 행렬을 구하는 함수

- D3DXMatrixRotationQuaternion, XMMatrixRotationQuaternion

```cpp
	printTitle("쿼터니온으로부터 회전 행렬을 구하는 함수");
	{
		XMVECTOR vQuaternion = XMQuaternionRotationAxis({ 1.0, 0, 0, 0 }, PI);
		printVector("vQuaternion", vQuaternion);
		/*
		1.0     0.0     0.0     -0.0
		*/
		XMMATRIX matRotation = XMMatrixRotationQuaternion(vQuaternion);
		printMatrix("matRotation", matRotation);
		/*
		1.0     0.0     0.0     0.0
		0.0     -1.0    -0.0    0.0
		0.0     0.0     -1.0    0.0
		0.0     0.0     0.0     1.0
		*/
	}
```

##### 길이가 1인 쿼터니온을 구하는 함수

- D3DXQuaternionNormalize, 

```cpp
	printTitle("길이가 1인 쿼터이온을 구하는 함수");
	{
		XMVECTOR vQuaternion = { 1.0, 2.0, 3.0, 4.0 };
		printVector("vQuaternion", vQuaternion);
		/*
		1.0     2.0     3.0     4.0
		*/
		vQuaternion = XMQuaternionNormalize(vQuaternion);
		printVector("vQuaternion", vQuaternion);
		/*
		0.2     0.4     0.5     0.7
		*/
	}
```



## 정점 변환



### 모델 좌표

- 3D 물체의 기준 좌표
- (0, 0, 0)을 기준으로 하는 정점의 좌표
- 3D 툴에서의 좌표계



### 정점 렌더링 파이프 라인



#### 월드 변환(World Transformation)

- 모델 좌표를 가진 물체의 정점들을 행렬변환(S * R * T)를 통해 렌더링 공간에 위치시키는 변환



#### 뷰 변환(View Transformation, Camera Transformation)

- 월드 공간의 모든 정점을 이동 및 회전시켜 뷰 공간으로 가져오는 변환
- 뷰(카메라) 좌표로 변환



##### 뷰 변환 행렬

- 뷰를 왼쪽으로 이동하기 위해서는 월드의 모든 정점을 오른쪽으로 이동시켜야한다.
  - 카메라(좌표계)가 고정되므로 정점을 이동시켜야한다.
- 스케일 행렬은 없음

$$
V = T \cdot R_z \cdot R_y \cdot R_x
$$

#### 투영변환(Projection Transformation)

- 원근 투영으로 가까운 물체와 먼 거리의 물체를 크게 또는 작게 표현하여 원근감이 있게 하는 변환
- 원근법을 적용하여 하나의 면에 정점을 위치시키는 변환



#### Clipping and Viewport Scaling

- 화면에 안보이는 정점을 제외시킴
- 화면(스크린) 좌표로 변환



### 변환함수

#### 월드, 뷰, 투영 행렬의 설정

```cpp
	LPDIRECT3DDEVICE9 pD3DDevice = nullptr;//초기화필요
	XMMATRIX matTransform;
	XMFLOAT4X4 matTransform2;
	XMStoreFloat4x4(&matTransform2, matTransform);
	pD3DDevice->SetTransform(D3DTS_WORLD, (D3DMATRIX*)&matTransform2);
```

- 모든 모델은 월드변환을 위한 행렬을 각각 보유한다.



#### 뷰 변환 행렬 함수

- D3DXMatrixLookAtLH, XMMatrixLookAtLH
- 뷰 변환 행렬은 일반적으로 하나이다.

```cpp
inline XMMATRIX XM_CALLCONV XMMatrixLookAtLH
(
    FXMVECTOR EyePosition, //카메라 위치
    FXMVECTOR FocusPosition, //바라보는 방향
    FXMVECTOR UpDirection //카메라에서 위쪽으로 향하는 벡터
)
```



#### 투영 변환 행렬 함수

- D3DXMatrixPerspectiveFovLH, XMMatrixPerspectiveFovLH

```cpp
inline XMMATRIX XM_CALLCONV XMMatrixPerspectiveFovLH
(
    float FovAngleY, //시야각
    float AspectRatio, //가로세로 비율, height/width
    float NearZ, //가까운 면까지 거리
    float FarZ // 먼 면까지 거리
)
```





## 깊이 버퍼 설정

- 깊이 버퍼를 사용하기 위한 D3D 설정

```cpp
	//D3D 파라미터의 z버퍼 설정
	sD3DParam.EnableAutoDepthStencil = true;
	sD3DParam.AutoDepthStencilFormat = D3DFMT_D24S8;
	
	//디바이스의 z버퍼 설정
	pD3DDevice->SetRenderState(D3DRS_ZENABLE, true);

	//렌더링 설정, D3DCLEAR_ZBUFFER 추가
	pD3DDevice->Clear(0, nullptr, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, D3DCOLOR_XRGB(0, 40, 100), 1.0f, 0);
```



## 뷰포트 설정

```cpp
	//Viewport
	D3DVIEWPORT9 d3dViewport9 = {};
	d3dViewport9.X = 0;//렌더링타겟 표면에서 뷰포트가 시작될 x위치
	d3dViewport9.Y = 0;//렌더링타겟 표면에서 뷰포트가 시작될 y위치
	d3dViewport9.Width = 800;//렌더링타겟에서 출력될 가로 크기
	d3dViewport9.Height = 800;//렌더링타겟에서 출력될 세로 크기
	d3dViewport9.MinZ = 0.0;//깊이버퍼의 최소 범위
	d3dViewport9.MaxZ = 1.0;//깊이버퍼의 최대 범위
	pD3DFramework->pD3DDevice->SetViewport(&d3dViewport9);
```



## 렌더링 파이프라인 만들기

- D3D 디바이스에 변환 행렬 적용
  - 정점 변환 행렬 
    - 월드 변환 행렬 적용
      - pD3DDevice->SetTransform(D3DTS_WORLD, (D3DMATRIX*)&f44)
    - 뷰 변환 행렬 적용
      - pD3DDevice->SetTransform(D3DTS_VIEW, (D3DMATRIX*)&f44);
    - 투영 변환 행렬 적용
      - pD3DDevice->SetTransform(D3DTS_PROJECTION, (D3DMATRIX*)&f44);
  - 변환 행렬 적용에 순서는 없음.
  - 월드 변환 행렬은 모델마다 다르지만 뷰, 투영 변환 행렬은 모델들이 공유하기 때문에 한번만 만들고 계속 사용할 수 있음.
- 정점을 그릴 수 있게 정보 설정
  - 정점 버퍼에 저장된 정점 버퍼와 정점 포맷을 D3D 디바이스에 알림
    - pD3DDevice->SetStreamSource
  - 정점 데이터를 해석하는 방법을 D3D 디바이스에 알림
    - pD3DDevice->SetFVF(D3DFVF_SVertex);
  - SetStreamSource에 의해 지정된 정점 버퍼의 정점을 그림

```cpp
	//World transformation
	XMMATRIX matWorld = XMMatrixScaling(1.0, 1.0, 1.0)//크기행렬
		*XMMatrixRotationX(0.0)//회전행렬
		*XMMatrixTranslation(0.0, 0.0, 0.0);//이동행렬
	XMFLOAT4X4 f44;
	XMStoreFloat4x4(&f44, matWorld);
	pD3DFramework->pD3DDevice->SetTransform(D3DTS_WORLD, (D3DMATRIX*)&f44);
	
	//View transformation
	XMMATRIX matView = XMMatrixLookAtLH(
		{ 10.0, 10.0, -10.0 },//카메라 위치
		{ 0.0, 0.0, 0.0 },//바라보는 방향
		{ 0.0, 1.0, 0.0 }//카메라에서 위쪽으로 향하는 벡터
	);
	XMStoreFloat4x4(&f44, matView);
	pD3DFramework->pD3DDevice->SetTransform(D3DTS_VIEW, (D3DMATRIX*)&f44);
	
	//Projection trasformation(직교투영)
	XMMATRIX matProj = XMMatrixOrthographicLH(
		50.0,
		50.0,
		1.0,//가까운 면의 Z값(음수를 넣으니 WM_SYSCOLORCHANGE가 계속와서 프로그램 진행이 안됨)
		100.0//먼 면의 Z값
	);
	XMStoreFloat4x4(&f44, matProj);
	pD3DFramework->pD3DDevice->SetTransform(D3DTS_PROJECTION, (D3DMATRIX*)&f44);
	
	//정점 출력
	//1. 버텍스버퍼와 버텍스 포맷을 D3D 디바이스에 알려준다. 출력할 버텍스버퍼를 출력 스트림과 연결한다.
	pD3DFramework->pD3DDevice->SetStreamSource(
		0,//0으로 지정
		pAxisVertexBufferInterface, //버텍스버퍼
		0, //메모리시작 위치
		sizeof(SVertex) //버텍스 크기
	);
	//2. D3D에 정점 데이터를 어떻게 해석해하는지 설정한다.
	pD3DFramework->pD3DDevice->SetFVF(D3DFVF_SVertex);
	//3. 기하 정보를 출력하기 위한 DrawPrimitive() 함수 호출
	//DrawIndexedPrimitive(), DrawPrimitiveUP(), DrawIndexedPrimitiveUP()등이 있고
	//DrawIndexedPrimitive(), DrawIndexedPrimitiveUP()함수가 게임개발에 많이 사용된다.
	//DrawIndexedPrimitive()함수가 가장 빠르다.
	pD3DFramework->pD3DDevice->DrawPrimitive(
		D3DPT_LINELIST,
		//D3DPT_TRIANGLESTRIP,
		0, //출력을 시작할 버텍스 인덱스
		3 //출력할 개수, 첫번째 파라미터 D3DPRIMITIVETYPE에 영향을 받는다.
	);
```



##  인덱스 버퍼

- 정점 버퍼에 들어간 정점의 인덱스를 이용하여 삼각형을 그릴 수 있게 인덱스를 활용하는 버퍼
- LP

### 정점과 인덱스 선언

- 인덱스는 WORD형으로 나열하며 삼각형은 시계(CW)방향으로 정점의 인덱스를 구성

```cpp
	//정육면체 정점
	SVertex2 sCubeVertices[8] = {
	{ {-10.0f, -10.0f, 0.0f}, 0xffffffff},
	{ {-10.0f, 10.0f, 0.0f}, 0xffff0000},
	{ {10.0f, 10.0f, 0.0f}, 0xff00ff00},
	{ {10.0f, -10.0f, 0.0f}, 0xff00ff},

	{ {-10.0f, -10.0f, 20.0f}, 0xffffffff},
	{ {-10.0f, 10.0f, 20.0f}, 0xffff0000},
	{ {10.0f, 10.0f, 20.0f}, 0xff00ff00},
	{ {10.0f, -10.0f, 20.0f}, 0xff0000ff},
	};

	//정육면체 인덱스, 면의 방향이 바깥을 향하도록 시계방향으로 그린다.
	WORD sCubeIndices[36] = {
		//앞
		0, 1, 2,
		0, 2, 3,
		//뒤
		7, 6, 5,
		7, 5, 4,
		//좌
		4, 5, 1,
		4, 1, 0,
		//우
		3, 2, 6,
		3, 6, 7,
		//상
		1, 5, 6,
		1, 6, 2,
		//하
		3, 7, 4,
		3, 4, 0,
	};
```



### 정점 버퍼  및 인덱스 버퍼 생성

```cpp
	//버텍스버퍼 생성
	pD3DFramework->pD3DDevice->CreateVertexBuffer(
		sizeof(sCubeVertices),//버텍스배열의 크기
		D3DUSAGE_WRITEONLY,//리소스 사용법을 지정(D3DUSAGE_WRITEONLY:어플에서 버텍스버퍼의 쓰기 조작만 수행함을 지정)
		D3DFVF_SVertex,//버텍스 타입
		D3DPOOL_DEFAULT,//리소스버퍼를 저장할 시스템, 비디오 메모리를 지정(D3DPOOL_DEFAULT:최적의 메모리를 자동 선택)
		&pCubeVertexBufferInterface,//반환된 버텍스버퍼를 받을 포인터
		nullptr//사용하지 않는 변수, nullptr
	);
	//버텍스버퍼에 버텍스를 저장하기 위해 잠금
	//Lock을 하면 다른 자원이 접근할 수 없게되고 정점을 저장할 메모리 포인터를 반환한다.
	void *pVertices;//버텍스를 저장할 메모리의 시작 주소를 받을 변수
	pCubeVertexBufferInterface->Lock(0, 0, (void**)&pVertices, 0);
	memcpy(pVertices, sCubeVertices, sizeof(sCubeVertices));//버텍스버퍼에 버텍스를 메모리 복사
	pCubeVertexBufferInterface->Unlock();//잠금을 해제

	//인덱스버퍼 생성
	pD3DFramework->pD3DDevice->CreateIndexBuffer(
		sizeof(sCubeIndices),//인덱스배열의 크기
		D3DUSAGE_WRITEONLY,//리소스 사용법을 지정(D3DUSAGE_WRITEONLY:어플에서 버텍스버퍼의 쓰기 조작만 수행함을 지정)
		D3DFMT_INDEX16,//인덱스 타입
		D3DPOOL_DEFAULT,//리소스버퍼를 저장할 시스템, 비디오 메모리를 지정(D3DPOOL_DEFAULT:최적의 메모리를 자동 선택)
		&pCubeIndexedBufferInterface,//반환된 인덱스버퍼를 받을 포인터
		nullptr//사용하지 않는 변수, nullptr
	);
	//인덱스버퍼에 인덱스를 저장하기 위해 잠금
	//Lock을 하면 다른 자원이 접근할 수 없게되고 인덱스를 저장할 메모리 포인터를 반환한다.
	void *pIndices;//인덱스를 저장할 메모리의 시작 주소를 받을 변수
	pCubeIndexedBufferInterface->Lock(0, sizeof(sCubeIndices), (void**)&pIndices, 0);
	memcpy(pIndices, sCubeIndices, sizeof(sCubeIndices));//인덱스버퍼에 인덱스를 메모리 복사
	pCubeIndexedBufferInterface->Unlock();//잠금을 해제
```



### 정점 버퍼 및 인덱스 버퍼 입력

```cpp
	
	//버텍스버퍼 입력
	//버텍스버퍼와 버텍스 포맷을 D3D 디바이스에 알려준다. 출력할 버텍스버퍼를 출력 스트림과 연결한다.
	pD3DFramework->pD3DDevice->SetStreamSource(
		0,//0으로 지정
		pCubeVertexBufferInterface, //버텍스버퍼
		0, //메모리시작 위치
		sizeof(SVertex2) //버텍스 크기
	);

	//인덱스버퍼 입력
	pD3DFramework->pD3DDevice->SetIndices(pCubeIndexedBufferInterface);
```



### 인덱스를 이용한 출력(DrawIndexedPrimitive)

- 정점 버퍼만 사용할 경우 DrawPrimitive() 함수를 사용했지만 인덱스 버퍼를 사용할 경우 DrawIndexedPrimitive() 함수를 사용한다.

```cpp
	pD3DFramework->pD3DDevice->DrawIndexedPrimitive(
		D3DPT_TRIANGLELIST,
		0,//정점버퍼의 시작인덱스 오프셋. 만약 1일 경우 인덱스 버퍼의 0값이 정점 버퍼의 1인덱스를 가리킨다.
		0,//정점버퍼의 최소인덱스. 만약 1일 경우 0번 정점은 사용되지 않는다.
		8,//그려질 정점의 개수, BaseVertexIndex + MinIndex 만큼 빼주면 된다.
		0,//인덱스버퍼의 시작인덱스 오프셋. 만약 1일 경우 1번 인덱스버퍼부터 그린다.
		12//그려질 도형(삼각형)의 개수
	);
```



## 컬링에 관한 설정

- 와이어프레임과 같이 컬링을 하지 않아야하는 경우

```cpp
	//렌더링하기 전 컬링을 하지 않도록 설정한다.
	pD3DFramework->pD3DDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);

	//렌더링 후 컬링을 다시 켜준다
	pD3DFramework->pD3DDevice->SetRenderState(D3DRS_CULLMODE, D3DCULL_CCW);
```



## SIMD(Single Instruction Multiple Data)

- 하나의 명령어로 여러 개의 값을 동시에 계산하는 방식
- 벡터 프로세서에서 많이 사용되는 방식으로, 비디오 게임 콘솔이나 그래픽 카드와 같은 멀티미디어 분야에 자주 사용된다.
- 인텔의 MMX(SSE2), 스트리밍 SIMD 확장(SSE), AMD의 3D 나우 등에서 이를 적용했다.
- 구현법
  - Intrinsic Function 이용
    - Intrinsic Function 
      - 모양은 함수와 같지만 어셈블리 명령어와 1:1로 매칭되어 좀 더 쉽게 SSE를 이용할 수 있게 해주는 내장 함수
  - 정렬된 메모리 사용(aligned memory)
    - 메모리의 시작점을 align한 숫자의 배수로 맞추고, 내부 원소의 크기를 align한 크기로 맞추는 것



## 도형

- D3DX에서 도형 제공
- 박스, 원기둥, 구, 주전자, 텍스트, 토러스, 폴리건



### 메쉬

- 정점들로 물체를 표현한 것
- 물체를 표현하기 위한 정점 집합
- LPD3DXMESH 타입으로 사용한다.
- 필요한 헤더와 라이브러리
  - D3dx9shape.h
  - D3dx9.lib



### 도형 생성 함수

- 메쉬를 생성하기 위한 함수



#### 박스

```cpp
HRESULT WINAPI 
    D3DXCreateBox(
        LPDIRECT3DDEVICE9   pDevice, //D3DDevice
        FLOAT               Width,
        FLOAT               Height,
        FLOAT               Depth,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency//nullptr
    );
```

#### 구

```cpp
HRESULT WINAPI
    D3DXCreateSphere(
        LPDIRECT3DDEVICE9  pDevice, 
        FLOAT              Radius, //반지름
        UINT               Slices, //구를 나누는 선분의 개수
        UINT               Stacks, //선분으로 나누어진 영역을 90도 방향으로 나누는 개수
        LPD3DXMESH*        ppMesh,
        LPD3DXBUFFER*      ppAdjacency//nullptr
    );
```

#### 주전자

```cpp
HRESULT WINAPI
    D3DXCreateTeapot(
        LPDIRECT3DDEVICE9   pDevice,
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency
    );
```

#### 원기둥

```cpp
HRESULT WINAPI 
    D3DXCreateCylinder(
        LPDIRECT3DDEVICE9   pDevice,
        FLOAT               Radius1, //윗면 원의 반지름
        FLOAT               Radius2, //아랫면 원의 반지름
        FLOAT               Length, //높이
        UINT                Slices, //원을 나누는 개수
        UINT                Stacks, //원을 나눈뒤 생기는 원기둥의 면을 나누는 개수
        LPD3DXMESH*         ppMesh,
        LPD3DXBUFFER*       ppAdjacency);
```



### 도형 출력 함수

- LPD3DXMESH의 멤버 함수 DrawSubset()을 이용한다.

```cpp
HRESULT __stdcall DrawSubset(
    DWORD AttribId //그리려는 서브셋 번호를 지정. 모든 삼각형을 그릴 경우 0.
);
```







## 영어

- reciprocal [risíprəkəl]
  - 상호의, 상응하는
- homogeneous [hòumədʒíːniəs]
  - 동종의, 순일의, 동원의
- strip
  - 스트립, 띠, 박탈하다, 벗기다, 박판
- translation
  - 평행 이동
- transformation
  - 변형, 변환



# 참고

- [https://abipictures.tistory.com/115](https://abipictures.tistory.com/115)
- [https://vallista.tistory.com/entry/DX-9-Direct3D-%EC%8B%9C%EC%9E%91](https://vallista.tistory.com/entry/DX-9-Direct3D-시작)
- DirectX 3D 게임 프로그래밍
  - [https://www.youtube.com/watch?v=xYDzdQAUF8E&list=PLOKPEzlY4JKSZLgY_jH4danTYinRKIPz1&index=10](https://www.youtube.com/watch?v=xYDzdQAUF8E&list=PLOKPEzlY4JKSZLgY_jH4danTYinRKIPz1&index=10)
- 정점 포맷과 정점 버퍼
  - [https://hellowoori.tistory.com/31](https://hellowoori.tistory.com/31)
- Working with D3DXMath
  - [https://docs.microsoft.com/en-us/windows/win32/dxmath/pg-xnamath-migration-d3dx](https://docs.microsoft.com/en-us/windows/win32/dxmath/pg-xnamath-migration-d3dx)
- [https://stonzeteam.github.io/SIMD-%EB%B3%91%EB%A0%AC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D/](https://stonzeteam.github.io/SIMD-병렬-프로그래밍/)
- http://blog.naver.com/PostView.nhn?blogId=qkfdjq451&logNo=220842864791&beginTime=0&jumpingVid=&from=search&redirect=Log&widgetTypeCall=true
- DrawIndexedPrimitive() 함수에 대하여 조금 상세히..
  - https://blog.naver.com/lgmpfree/100055862741
- 

