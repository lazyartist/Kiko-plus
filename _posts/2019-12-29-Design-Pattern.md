---
layout: post
title: "Design Pattern"
description: ""
date: 2019-12-29 19:00:00+09:00
tags: [Design Pattern]
comments: true
share: true
---

[TOC]



## 좋은 소프트웨어 구조

- 새로운 작업을 할 때 코드를 거의 건드리지 않고 적당한 함수 몇 개만 호출하면 원하는 작업을 할 수 있는 코드 및 구조
- 변화가 쉬운 코드
- 작업에 들어가기 전에 기존 코드를 파악하는(알아야할 지식) 양이 적은 구조
  - 디커플링



## 추상화와 디커플링의 적절한 적용

- 유연함이 필요할지 확신이 안선다면 추상화와 디커플링을 적용하느라 시간 낭비 말라.
- 저수준의 핵심 최적화는 가능한 늦게 하라.
- 버릴 코드는 빠르게 기능을 확인하는 것이다.



## 디자인 패턴

### 명령(Command ) 패턴

- 메서드 호출을 실체화한 것
  - 실체화
    - 어떤 개념을 변수에 저장하거나 함수에 전달할 수 있도록 데이터(객체)로 바꿀 수 있다.
  - 메서드 호출을 객체화하여 전달하는 것
- 콜백을 객체지향적으로 표현한 것
- 비슷한 개념
  - 콜백
  - 일급 함수
    - 자바스크립트의 함수와 같이 함수를 할당, 전달, 반환 할 수 있는 함수
  - 함수 포인터
    - 상태값을 가지지 않지만 간단한 기능에는 사용할 수 있겠다.
  - 클로저
    - 현재 문맥(context)의 값을 저장하는 함수 객체를 간단히 만들어주므로 명령 패턴을 구현하기 이상적인 기술이지만 너무 자동화를 잘해줘서 클로저가 어떤 상태를 갖고 있는지 알아보기 어렵다.
    - 위키백과 : 컴퓨터 언어에서 클로저(Closure)는 [일급 객체 함수](https://ko.wikipedia.org/w/index.php?title=일급_객체_함수&action=edit&redlink=1)(first-class functions)의 개념을 이용하여 스코프(scope)에 묶인 변수를 바인딩 하기 위한 일종의 기술이다. 기능상으로, 클로저는 함수를 저장한 [레코드](https://ko.wikipedia.org/wiki/레코드)(record)이며, 스코프(scope)의 인수(Factor)들은 클로저가 만들어질 때 정의(define)되며, 스코프 내의 영역이 소멸(remove)되었어도 그에 대한 접근(access)은 독립된 복사본인 클로저를 통해 이루어질 수 있다.
  - 부분 적용(partial application) 함수
    - 여러 함수를 거쳐 결과를 반환하는 함수일 경우 중간까지만 계산한 값을 갖고 있는 함수를 나중에 실행하는 것.



### 경량(Flyweight) 패턴

- 어떤 객체의 개수가 너무 많아서 좀 더 가볍게 만들고 싶을 때 사용



#### 경량 패턴을 사용하기 위한 데이터의 분류

- 고유 상태(intrinsic state)
  - 모든 객체의 데이터 값이 같아서 공유할 수 있는 데이터
- 외부 상태(extrinsic state)
  - 인스턴스별로 값이 다른 데이터



#### 경량 패턴 예

- 지형 데이터
  - 지형이 한정된 타입으로 구성된 경우, 타입별 지형을 만들고 전체 지형은 생성된 지형의 포인터만 갖는다.
- 경량 패턴의 객체는 여러곳에서 공유하기 때문에 변경 불가능한(immutable) 상태로 만드는게 보통이다.



### 관찰자(Observer) 패턴

#### 관찰자 패턴 구성 요소

- 대상(Subject)
  - 특정 조건이 되면 관찰자 목록에 저장된 객체의 특정 메서드(onNotify())를 호출하는 객체
- 관찰자(Observer)
  - 대상 객체에 등록되어 특정 조건에 메서드(onNotify())가 호출되는 객체



#### 관찰자 패턴 사용시 주의점

- 멀티스레드, 락(lock)과 함께 사용할 때는 조심
  - 관찰자 목록의 통지 메서드를 호출할 때 락이 걸린다면 게임 전체가 교착상태에 빠질 수 있다.
- 관찰자 등록에 동적할당 컬렉션을 사용한다면 메모리 단편화가 생길 수도 있다.
  - vector같은 동적할당 컬렉션은 용량 부족 시 기존 용량의 두 배 가량의 메모리를 새로 할당받아 복사하고 기존 메모리는 해제하기 때문에 단편화가 생길 수 있다.
  - 따라서 연결 리스트로 구현하면 객체가 늘어나도 기존 용량을 해제하는 단편화가 생기지 않는다.
    - 이중 연결 리스트라면 추가/삭제가 더 간편하다.
- 관찰자 패턴은 서로 연관없는 코드 덩어리들이 서로 상호 작용하기 좋은 방법이다.
  - 하나의 기능을 구현하기 위한 코드 덩어리는 명시적으로 연결하는게 더 낫다.



#### 연결리스트 관찰자 패턴의 포인터의 포인터 예제 해석

[https://gist.github.com/parkpd/4638874487a358e27957971394d42e90](https://gist.github.com/parkpd/4638874487a358e27957971394d42e90)

```cpp
void Subject::removeObserver(Observer* observer) {
  //head변수의 포인터를 받지 않으면 head가 observer일 경우 head에 observer->next를 할당하는 코드가 필요하다.
  Observer** current = &head_;
  while (*current != NULL) {
    if (*current == observer) {
      *current = (*current)->next_;
      observer->next_ = NULL;
      return;
    }
    current = &(*current)->next_;
  }
}) 
```



#### 요즘의 관찰자 패턴

- 언어 자체적으로 지원하는게 많다.
  - C# : event
  - Java : EventListener
- 클로저가 있는 언어는 클로저로 구현하는 경우가 많다.



#### 미래의 관찰자 패턴

- UI같이 성능에 덜 민감하고 데이터에 따른 갱신이 필요한 분야에서는 데이터 바인딩 방식이 대세가 될 것이다.



### 프로토타입(Prototype) 패턴

- 객체를 생성할 때 클라스가 아닌 인스턴스로부터 생성하는 방식



#### CPP에서 프로토타입

- cpp에서는 clone함수를 만들어 객체의 생태를 복사하는 형식으로 만들어야하는데 이는 코드 양도 많고 요즘 일반적인 방법은 아니다. 
- 다음과 같이 클래스를 사용하는 방식이 프로토타입을 구현한 것은 아니지만 비슷하게 사용할 수 있는 방법이다.
  - cpp에서는 클래스가 일급 자료형이 이니므로 클래스를 함수의 매개변수로 전달하지 못하기 때문에 이와 같은 방법이 필요하다.
  - 자바스크립트, 파이썬, 루비 등은 클래스가 일급 자료형이다.



##### 몬스터를 스폰하는 프로토타입 예제(함수포인터 사용)

- 몬스터를 생성하는 함수 정의
- 몬스터 생성 함수를 저장하는 스폰 클래스 정의

```cpp
//Ghost는 Monster를 상속한다.
Monster* spawnGhost(){
	return new Ghost();
}

typedef Monster* (*SpawnCallback)(); //Monster반환 함수 포인터

class Spawner{
    public:
    	Spawner(SpawnCallback spawn) spawn_(spawn){}
    	Monster* spawnMonster(){return spawn_();}
    private:
    	SpawnCallback spawn_;
}
//스폰 객체 생성
Spawner* ghostSpawner = new Spawner(spawnGhost);
//몬스터 스폰
ghostSpawner.spawnMonster();
```



##### 몬스터를 스폰하는 프로토타입 예제(템플릿 사용)

- 스폰 클래스 정의
- 템플릿 타입 매개변수로 몬스트 클래스 전달

```cpp
//Spawner 클래스를 따로 만드는 이유는 몬스터를 스폰하는 코드에 매번 템플릿 매개변수로 Monster 관련 클래스를 넣지 않기 위함
class Spawner {
    public:
    	virtual ~Spawner(){}
    	virtual Monster* spawnMonster() = 0;
};

template <class T>
class SpawnerFor : public Spawner{
    public:
    	virtual Monster* spawnMonster(){
            return new T();
        }
}

// 스폰 객체 생성, Ghost는 Monster의 유도객체
Spawner* ghostSpawner = new SpawnerFor<Ghost>();
```



#### 프로토타입 언어 패러다임

- 객체를 원형으로 하여 복제의 과정을 통하여 객체의 동작 방식을 다시 사용할 수 있는 프로그래밍 방식
- 프로토타입 최고 구현 언어는 셀프이다.



##### 자바스크립트에서의 프로토타입

- 언어적으로 프로토타입을 기본으로 제작되었지만 객체의 복제를 지원하지 않고 클래스 기반의 프로그래밍 방식을 사용하고 있다.



##### 자바스크립트 객체 생성 방식

- new로 인해 빈 객체가 생성되고 생성자 함수의 this로 바인딩된다.
- 생성된 객체의 `__proto__` 필드에 생성자 함수의 prototype을 저장한다.
- 생성자 함수의 반환값으로 새로운 객체를 반환한다.

```js
//클래스 정의(JS에서 클래스는 생성자 함수의 정의와 같다)
function A(b){
	this.b = b; //b라는 필트를 추가한다.
}
//A의 prototype에 fn 함수를 추가한다. new A(1) 이후에 해도 상관없다.
A.prototype.fn = function(){
    console.log(this.b);
};

var a = new A(1);
a.__proto__; // a에 필드가 없을 때 위임하는 객체, A.prototype
a.fn(); // 1, a객체에 fn필드가 없기 때문에 위임 객체는 A.prototype객체에 fn이 있는지 찾아 호출한다.

```



#### 데이터 모델링을 위한 프로토타입

- 데이터에 프로토타입 언어와 같이 위임을 설정할 수 있다면 이를 활용하여 데이터의 중복을 제거할 수 있다.
- Json과 같은 데이터 구조에서 프로토타입을 대른 데이터로 지정한다면 공통되는 필드를 모두 지정하지 않아도 프로토타입의 위임 기능으로 찾아올 수 있다.

```js
var a = {
	name:"abc",
};
var b = {
	hp:10
};
b.__proto__ = a;//(참고로 a는 함수가 아니므로 protytype필드가 없다)
console.log(b.name); // abc
```



### 싱글턴(Singleton) 패턴

- 오직 한 개의 클래스 인스턴스만을 갖도록 보장하고, 이에 대한 전역적인 접근점을 제공



#### 싱글턴을 사용하는 이유

- 한 번도 사용하지 않는다면 아예 인스턴스를 생성하지 않는다.
- 런타임에 초기화된다.
  - 싱글턴 대신 정적 멤버 변수를 사용할 수 있지만 정적 멤버 변수는 다음과 같은 단점이 있다.
    - 정적 멤버 변수는 자동 초기화된다.
      - 따라서 프로그램 실행 이후에 알 수 있는 정보를 활용할 수 없다.
      - 초기화 순서를 컴파일러에서 보장해주지 않기 때문에 다른 정적 변수에 안전하게 의존할 수 없다.
    - 싱글턴은 최대한 늦게 초기화 된다.
- 싱글턴을 상속할 수 있다.



#### 싱글턴이 문제인 이유

- 싱글턴은 사실 전역 변수와 같다.
  - 전역 변수는 코드를 이해하기 어렵게 한다.
    - 정적 변수의 값을 바꾸는 곳을 찾기가 쉽지 않다.
  - 전역 변수는 커플링을 조장한다.
  - 전역 변수는 멀티스레딩 같은 동시성 프로그래밍에 맞지 않다.
- 싱글턴은 문제가 하나일 때도 두 가지 문제를 풀려 한다.
  - 오직 한 개의 인스턴스만 필요한 경우
  - 전역 접근이 필요한 경우
- 게으른 초기화는 제어할 수가 없다.
  - 인스턴스가 사용되는 시점에 초기화 된다면 성능이 중요한 곳에서 느려질 수 있다.
  - 게이른 초기화는 메모리 단편화를 불러올 수 있다.
    - 이를 해결하기 위해 싱글턴 멤버 변수를 포인터가 아닌 변수로 만들어 main 함수가 불리기 전에 초기화가 되도록 강제할 수 있다.
      - 이는 또 다른 단점을 불러온다.
        - 다형성을 활용할 수 없다.
        - 인스턴스가 필요없어도 메모리를 해제할 수 없다.
      - 정적 멤버로 해결 할 수 있다면 instance() 함수 대신 정적 멤버를 사용하는게 더 명확한 코드이다.



#### 싱글턴의 대안

- 싱글턴이 단순히 다른 클래스의 인스턴스의 관리용이라면 기능을 클래스로 옮긴다.
- 인스턴스가 하나만 필요하다면 생성자에 단언문(assert) 등으로 이미 생성된 인스턴스가 있는지 확인한다. 
- 싱글턴은 인스턴스에 쉽게 접근할 수 있기 때문에 널리 쓰인다. 이를 해결하여 싱글턴 사용을 줄일 수 있다.
  - 넘겨주기, 의존성 주입(dependency injection)
    - 필요로 하는 의존 객체를 전역이 아닌 매개변수로 받아서 사용한다.
  - 상위 클래스로부터 얻기
  - 이미 전역인 객체로부터 얻기
  - 서비스 중개자로부터 얻기
    - 전역 접근을 제공하는 용도로만 사용하는 클래스를 따로 정의하여 전역 인스턴스를 제공한다.
- 싱글턴을 사용하지 않고도 게임을 만들 수 있다.
  - 인스턴스를 하나로 제한할 경우 
    - 정적 클래스를 사용
    - 생성자에 정적 플래그를 둬서 런타임에 인스턴스 개수 검사
- 여튼 싱글턴은 전역적으로 데이터를 변경시킬 수 있기 때문에 최소화해야한다.







## 용어

- 큐잉(queuing)
  - ?
- 









## 영어

- intrinsic *[intrínsik]*
  - 본질적인, 고유한, 내재한
- extrinsic *[ikstrínsik]*
  - 비본질적인, 고유의 것이 아닌, 외부(로부터)의

# 참고

- [서적] 게임 프로그래밍 패턴 / 로버트 나이트롬, 박일
  - http://gameprogrammingpatterns.com/contents.html
- 