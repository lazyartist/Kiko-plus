---
layout: post
title: "Win32 - API"
description: ""
date: 2019-05-28 00:00:04
tags: [win32]
comments: true
share: true
---

[TOC]



## 윈도우 프로그래밍 구조

- WinMain
  - 응용 프로그램 윈도우 생성
  - 윈도우 프로그램의 진입점
- WndProc
  - 메시지 처리



## 인스턴스(HINSTANCE)와 핸들(HWND)

- 운영체제가 부여하는 값으로써 응용 프로그램과 할당된 자원을 구분하는 방법
- 인스턴스와 핸들의 실체는 값이다.
- 인스턴스와 핸들의 값을 저장하기 위해 HINSTANCE, HWND 데이터형을 사용하고 이 데이터형은 결국 void* 형으로서 4바이트(혹은 8바이트)이다.



### void* 형의 크기

```
sizeof(void*); // 4, x86
sizeof(void*); // 8, x64
```



### 인스턴스

- 응용 프로그램의 아이디값으로서 여러개 실행되어도 같은 값을 가진다.
- 다른 응용 프로그램과 중복되지 않는다.
- 거의 사용하지 않는다.



### 핸들

- 운영체제에서 할당한 자원의 아이디값으로서 할당된 자원별로 독립된 값을 가진다.
  - 윈도우, 펜, 브러쉬 등
  - HWN, HDC, HPEN, HBRUSH 등..
- 인스턴스와 다르게 같은 종류의 프로그램이라도 여러개 실행 시 다른 핸들 값을 갖는다.
- 많이 사용된다.



## 변수명에 붙이는 접두사

| 데이터형       | 접두사     |
| -------------- | ---------- |
| DWORD          | dw         |
| 문자열         | sz, s, str |
| 포인터         | p          |
| 핸들           | h          |
| 전역변수       | g_         |
| 윈도우 메시지  | msg        |
| Count of bytes | cb         |

- Coding Style Conventions
  - <https://docs.microsoft.com/en-us/windows/desktop/stg/coding-style-conventions>



## Window Class 구조체와 Window Procedure

- OS에서 발생한 메시지에 대해 처리를 하는 역할을 한다.
- 실행되는 프로그램은 Window 단위로 작업을 처리하고 Window에서 발생한 메시지를 처리하는 함수가 Procedure이다.
- 동일한 처리를 하는 Procedure는 여러 프로그램이 공유하여 자원을 아낄 필요가 있었고 이를 해결하기 위해 Window Class라는 구조체에 Procedure를 할당하고 이 Window Class를 등록하여 필요한 프로그램이 가져다 쓸 수 있게 만들었다.
- Procedure의 공유를 위해 Window Class 구조체를 만들었지만 Window를 생성하는 초기값으로 반드시 필요한 정보들도 함께 들어가게 되어었다.



## WinMain()

### 역할

- 윈도우 구조체 등록, 생성
  - 화면에 출력할 윈도우의 형태를 구조체에 세팅
  - 세팅된 구조체를 기반으로 윈도우 생성
  - 설정해야할 값(변수)이 많기 때문에 함수의 파라미터로 전달하지 않고 구조체를 만들어 전달 
- 윈도우 생성과 출력
- 메시지 루프
  - 메시지 체크
    - 운영체제가 생성해서 저장한 메시지가 들어있는 메시지 큐에서 자신에게 해당하는 메시지가 있는지를 메시지 루프를 통해 확인하고 가져옴
    - 메시지 루프를 돌지 않으면 운영체제는 생성한 메시지를 자동으로 전달하지 않음



### WinMain() 작성순서

#### Window Class 구조체 설정

Window의 프로시저, 모양, 클래스 이름 등이 설정된 Window Class를 생성한다.

```cpp
// 1. Window Class 구조체 설정

// Window Class 구조체 생성
WNDCLASSEX wcex;

// WNDCLASSEX의 크기를 입력
// cb : count of bytes
wcex.cbSize = sizeof(WNDCLASSEX);

// 윈도우 출력 형태 지정. 가로, 세로 사이즈가 변하면 전체를 다시 그린다.
wcex.style = CS_HREDRAW | CS_VREDRAW;

// 메시지 처리에 사용될 함수
wcex.lpfnWndProc = WndProc;

// 동일한 'Window Class'를 사용하는 Window들이 공유할 수 있는 메모리 크기를 설정
// 40바이트까지 제한.
// SetClassWord, SetClassLong, GetClassWord, GetClassLong 함수를 사용하여 사용
// 보안에 취약하고 크기도 제한적이라서 거의 사용하지 않음.
wcex.cbClsExtra = 0;

// 이 'Window Class'를 사용하는 Window를 위한 개별 메모리를 추가. 동일한 'Window Class'를 사용해도 공유되지 않는다.
// 40바이트까지 제한
// SetWindowLong, GetWindowLong 함수를 사용하여 사용
// 거의 사용하지 않음.
wcex.cbWndExtra = 0;

// 윈도우 인스턴스
wcex.hInstance = hInstance;

// 기본 아이콘 지정, OS에서 미리 정의한 아이콘을 사용할 수 있다.
// IDI : ID for an icon
// 방법 1. 리소스의 이름을 문자열 포인터로 전달
wcex.hIcon = LoadIcon(NULL, "resourceName");
// 방법 2. Resource.h에 define된 리소스 아이디를 MAKEINTRESOURCE를 이용해 문자열 포인터 형식으로 변경
// 리소스 아이디로 변경된 문자열 포인터는 유효하지 않지만 OS는 이를 ID값으로 사용하여 문자열을 찾는다.(?)
wcex.hIcon = LoadIcon(NULL, MAKEINTRESOURCE(IDI_APPLICATION)); // IDI_APPLICATION : 운영체제에 미리 정의된 기본 아이콘

// 기본 작은 아이콘 지정
wcex.hIconSm = LoadIcon(NULL, MAKEINTRESOURCE(IDI_APPLICATION));

// 기본 커서 지정, OS에서 미리 정의한 커서를 사용할 수 있다.
// IDC : ID for an cursor
wcex.hCursor = LoadCursor(NULL, IDC_ARROW);

// 윈도우의 배경 색을 지정
// 방법 1. CreateSolidBrush()로 브러시를 직접 생성하여 할당. 
// 프로그램 종료 시 반드시 해제해야한다.
HBRUSH brushBg = CreateSolidBrush(RGB(0, 0, 0));
wcex.hbrBackground = brushBg;
// 방법  2. OS가 미리 설정한 상숫값 사용
// COLOR_WINDOW : 회색
// COLOR_WINDOW + 1 : 흰색
// COLOR_WINDOW + 2 : 어두운 회색
// COLOR_WINDOW + 3 : 검은색
wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
// 방법 3. OS가 미리 만들어 놓은 Stock Resource를 가져다 사용
// OS가 사용빈도가 높은 자원을 미리 만들어 놓는데 이 자원을 Stock Resource 또는 Stock Object라 한다.
// 이 자원중 WHITE_BRUSH에 해당하는 자원의 핸들값을 얻어 배경색으로 지정한다.
// 반환값이 HGDIOBJ이므로 형변환하여 사용한다.
wcex.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);

// Window Class의 이름을 지정하고 이 이름으로 Window Class를 구분하기 때문에 다른 Window Class와 중복되지 않게 잘 지정한다.
// 대소문자를 구분하지 않는다. 
LPCTSTR strClassName = TEXT("Win32");
wcex.lpszClassName = strClassName;

// 메뉴 이름
wcex.lpszMenuName = NULL;
```



#### Window Class 구조체 등록

```cpp
// 2. Window Class 구조체 등록
RegisterClassEx(&wcex);
```



#### Window 생성

```cpp
// 3. Window 생성
HWND hWnd = CreateWindow(
	strClassName, // LPCSTR lpClassName : Window Class 이름
	TEXT("Hello World"), // LPCSTR lpWindowName : 윈도우 타이틀 이름
	WS_OVERLAPPEDWINDOW, // DWORD dwStyle : 윈도우 스타일, dw(DWORD)
	CW_USEDEFAULT, 0, // int X, int Y : 윈도우 x, y 좌표, CW(Create Window), CW_USEDEFAULT : 운영체제가 정한 기본값을 사용한다.
	CW_USEDEFAULT, 0, // int nWidth, int nHeight : 윈도우 가로, 세로 크기(클라이언트 영역 포함)
	nullptr, // HWND hWndParent : 부모 윈도우 핸들
	nullptr, // HMENU hMenu : 메뉴 핸들
	hInstance, // HINSTANCE hInstance : 응용 프로그램 인스턴스
	nullptr // LPVOID lpParam : 생성 윈도우 정보, 여유분으로 사용하지 않는다.
);
```



#### 윈도우 출력

```cpp
// 4. 윈도우 출력
// 방법 1. 프로그램 실행 시 넘어온 ShowWindow Commands를 사용한다.
ShowWindow(hWnd, nCmdShow);
// 방법 2. 미리 정의된 ShowWindow Commands를 사용한다.
ShowWindow(hWnd, SW_SHOW);
// WM_PAINT 메시지를 발생시켜 윈도우를 그린다.
UpdateWindow(hWnd);
```



#### 메시지 루프

- GetMessage()
  - 메시지 큐에 있는 메시지를 가져온다.
  - WM_QUIT 이 발생하면 FALSE를 리턴하고 그 외에는 TRUE를 리턴한다.
- TranslateMessage()
  - 가져온 메시지가 문자키 입력일 경우 TranslateMessage() 함수에서 WM_CHAR를 만들어 메시지 큐에 덧붙인다.
- DispatchMessage()
  - 메시지를 WndProc에 전달하기 위해 DispatchMessage를 호출한다.
  - DispatchMessage 함수 내부에서 WndProc 함수를 호출한다.
  - WndProc() 함수가 종료될 때까지 대기

```cpp
// GetMessage() : 가져올 메시지가 없으면 대기한다.(반환하지 않는다)
// 게임에서는 대기하지 않고 결과를 바로 리턴하는 PeekMessage()를 사용한다.
MSG msg;
while(GetMessage(&msg, NULL, 0, 0)){
	TranslateMessage(&msg);
	DispatchMessage(&msg);
}
```



#### 메시지 처리 과정

- 하드웨어
  - (키보드, 마우스 등)이벤트 발생
  - 이벤트 감지
- 운영체제
  - 메시지 전송
  - 메시지 큐에 저장
- 어플리케이션
  - WinMain 메시지 큐에서 메시지 확인하고 가져옴
  - TranslateMessage를 통해 문자입력을 가공하고 DispatchMessage로 WndProc 함수를 호출



## WndProc()

### 역할

- 메시지가 발생한 경우 어떻게 처리할지를 정의
  - switch문으로 각 메시지별 처리를 한다.
  - 처리되지 않은 메시지는 DefWndProc()을 호출하여 처리한다.
- 메시지
  - 양의 정수값



### 메시지 종류

- WM_xxx
  - 윈도우 메시지
  - WM_PAINT
    - 최초 UpdateWindow() 함수에 의해 발생
    - 윈도우의 일부 영역을 새로 출력할 때 운영체제에서 발생
  - WM_DESTROY
    - 윈도우가 화면에 사라진 후에 보내는 메시지
    - 메모리에서 제거되기 직전에 보냄
    - PostQuitMessage(0)을 호출하여 WM_QUIT 메시지를 발생시킨다.
  - WM_QUIT
    - 
- CB_xxx
- LM_xxx
- PBM_xxx



### wParam, lParam

- 메시지의 부가정보를 담고 있다.
- 16비트 OS에서 wParam은 WORD 즉, 2바이트이고 lParam은 LONG 즉, 4바이트였다.
- 32비트 OS에서는 wParam, lParam 둘 다 4바이트이다.
- 따라서 w와 l은 WORD와 LONG을 나타내는 접두어였지만 이제는 단순한 이름일뿐이다.





## 리소스(Resource)

- 리소스 편집기를 활용하여 커서, 메뉴, 아이콘, 문자열, 비트맵, 다이얼로그, 엑셀레이터 등을 추가/편집
- 리소스를 윈도우 기본으로 설정 시 인스턴스는 NULL로 설정
- 활용빈도 순서
  1. 메뉴, 다이얼로그, 비트맵
  2. 커서, 아이콘
  3. 엑셀레이터
  4. 문자열
- 리소스 아이디
  - resource.h 헤더 파일에 정의
- 리소스 파일
  - 리소스 아이디로 실제 값을 찾을 때 실제 값이 들어있는 파일
  - 확장자 : *.rc
  - VS 내에서 스크립트 언어로 작성됨
- VS 프로젝트에서 '리소스 추가'를 통해 추가 가능



### 아이콘 리소스

- 크기
  - 16, 32, 48 픽셀
- 색상
  - 4, 8, 32 비트
  - 기본 4비트, 32x32
- 아이콘 아이디 접두사
  - IDI_ : ID Icon
- 편집 창에서 청녹색 픽셀은 실제 출력시 투명하게 처리된다.



### 커서 리소스

- 커서 아이디 접두사
  - IDC_ : ID Cursor
- 핫 스폿(hot spot) 설정
  - 커서가 윈도우 영역 안에 있는지를 판단하는 좌표, 마우스 포인터의 중심
  - 설정하기
    - 아이콘 에디터 > 핫 스폿 설정 도구
    - 핫 스폿으로 지정할 픽셀을 클릭
  - 핫 스폿 확인하기
    - 커서 아이콘 우클릭 > 속성 > Hot spot 
- 커서 설정
  - 마우스 이동 시 발생하는 WM_MOUSEMOVE, WM_SETCURSOR 메시지에서 SetCursor()로 설정
    - LoadCursor를 이용해 얻은 커서의 핸들을 SetCursor에 넘김

```cpp
switch (message)
{
	case WM_SETCURSOR:
		HCURSOR hCursor;
		hCursor = LoadCursor(g_hInstance, MAKEINTRESOURCE(IDC_CURSOR1));
		SetCursor(hCursor);
		break;
	...
}
```



### 메뉴 리소스

- 메뉴 아이디 접두사
  - IDR_ : ID Resource(?) 
  - 왜 얘만 ID Resource 일까?
- 윈도우 상단바의 메뉴를 구성
- 각 메뉴별 아이디가 부여되고 이 값을 WM_COMMAND 메시지에서 처리
- wParam의 아래 2바이트가 메뉴의 아이디값
  - 이 값으로 어떤 메뉴가 눌렸는지 판단
- wParam의 위 2바이트가 이벤트값
  - 이 값으로는 뭐하나?

```cpp
switch (message)
	{
	case WM_COMMAND:
	{
		WORD menuId = LOWORD(wParam);
		WORD menuEvent = HIWORD(wParam);
        switch(menuId)
        {
            case 00:
                break;
            ...
        }
    }
}
```



### 문자열 리소스

- 문자열 아이디 접두사
- resource.h 파일에 문자열 아이디와 캡션(내용)을 저장
- LoadString()을 통해 리소스파일에 저장된 문자열을 읽어 파라미터로 넘긴 버퍼에 저장

```cpp
TCHAR szWindowName[100];
LoadString(hInstance, IDS_TITLE, szWindowName, 100);
```



## 윈도우즈의 구성

- Kernel
  - 메모리를 관리하고 프로그램을 실행
- USER
  - 유저 인터페이스와 윈도우를 관리
- GDI
  - 화면 처리와 그래픽을 담당



## 그래픽

### GDI (Graphics Device Interface)

- 운영체제의 한 부분으로 출력을 담당(Gdi.dll)
- 그래픽 드라이버와 관련된 처리를 담당
- 직접 사용할 수 없고 DC에 원하는 값을 설정하면 GDI가 이를 이용해 화면을 구성함







### DC (Device  Context)

- 출력에 필요한 모든 정보를 가지는 데이터 구조체
- GDI 모듈에 의해 관리됨
- 출력하기 위한 장치(화면, 프린터)의 특성을 저장하는 구조체
- 어플리케이션과 GDI를 연결해주는 것으로 어플리케이션은 DC를 통해 GDI에 명령을 전달
- Application --- DC --- GDI
- 데이터형
  - HDC(핸들)
- DC를 사용하는 그래픽 오브젝트
  - **비트맵**, **브러쉬**, **펜**, 팔레트, 폰트, Region, Path 등



#### DC 관련 함수

##### BeginPaint()

- HDC를 가져오는 역할
- WM_PAINT 메시지 처리에서만 사용 가능
- 기존에 존재하는 DC를 얻어온다.

```cpp
/*
HWND hWnd : 윈도우 핸들
LPPAINTSTRUCT lpPaint : 출력 영역에 대한 정보를 저장할 PAINTSTRUCT 구조체의 포인터
*/
HDC BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);
```



###### PAINTSTRUCT 구조체

- 출력 영역에 대한 상세 정보가 저장된다.
- fErase 값이 true인 경우
  - 응용 프로그램이 직접 배경을 삭제해야 함
  - 이를 위해서 hbrBackground를 NULL로 설정해야 함

```cpp
typedef struct tagPAINTSTRUCT {
    HDC         hdc; // 출력 영역(DC)에 대한 핸들 값
    BOOL        fErase; // 배경 삭제 여부
    RECT        rcPaint; // RECT 구조체
    BOOL        fRestore; // 시스템에서 사용
    BOOL        fIncUpdate; // 시스템에서 사용
    BYTE        rgbReserved[32]; // 시스템에서 사용
} PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;
```



##### EndPaint()

- WM_PAINT 메시지 처리에서만 사용 가능
- BeginPaint()를 사용한 경우 반드시 EndPaint()를 호출해 끝을 알려야한다.

```cpp
/*
HWND hWnd : 윈도우 핸들
LPPAINTSTRUCT lpPaint : 출력 영역에 대한 정보를 저장할 PAINTSTRUCT 구조체의 포인터
*/
HDC EndPaint(HWND hWnd, const PAINTSTRUCT *lpPaint);
```

- [x] BeginPaint는 두 번째 파라미터가 LPPAINTSTRUCT lpPaint인데 왜 EndPaint는 PAINTSTRUCT *lpPaint일까?
  - lpPaint를 포인터 상수(pointer to constant)로 받아 내부에서 변경하지 않음을 명확히 해려하는데 PAINTSTRUCT의 포인터 상수(pointer to constant)가 정의되어있지 않기 때문에 const PAINTSTRUCT *lpPaint로 선언된 듯하다.



##### GetDC()

- WM_PAINT 메시지 처리 영역 이외의 곳에서 DC를 얻어 올 수 있다.
- 호출 시 윈도우 핸들 값을 입력하면 윈도우 클라이언트 영역에 대한 디바이스 콘텍스트를 반환한다.
- 기존에 존재하는 DC를 얻어온다.

```cpp
/*
HWND hWnd : 윈도우 핸들
return HDC: 윈도우 클라이언트 영역에 대한 DC(Device Context)
*/
HDC GetDC(HWND hWnd);
```



##### ReleaseDC()

- GetDC()로 얻은 DC를 해제한다.
- GetDC()를 사용했다면 반드시 ReleaseDC()를 호출하여 자원을 반납해야한다.

```cpp
/*
HWND hWnd : 윈도우 핸들
HDC hDC : GetDC()로 얻은 DC
return int : ?
*/
int ReleaseDC(HWND hWnd, HDC hDC);
```



### GDI 오브젝트

- GDI가 그래픽 출력을 위해 사용하는 도구
- 사용자가 GDI 출력을 조정할 수 있는 도구
- GDI 오브젝트를 만들면 핸들을 발급 받고 이 핸들로 GDI 오브젝트를 사용한다.



#### Stock Object

- OS가 사용빈도가 높은 GDI 오브젝트 자원을 미리 만들어 놓는데 이 자원을 Stock Resource 또는 Stock Object라 한다.
- OS가 제공해주므로 생성/파괴를 할 필요가 없다.



#### GetStockObject

- Stock Object를 얻기 위한 함수
- 얻고 싶은 자원의 아이디를 인자로 넘기면 HGDIOBJ 형식으로 반환하므로 원하는 핸들 타입으로 형변환하여 사용한다.

```cpp
HGDIOBJ GetStockObject(int i);

wcex.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
```



#### GDI 오브젝트 생성



#### GDI 오브젝트 사용

##### SelectObject()

- GDI 오브젝트를 사용하기 위해 HDC가 선택하도록 한다.

``` cpp
/*
HDC hdc : DC
HGDIOBJ h : DC에 선택할 GDI 오브젝트 핸들러
return : 현재 선택되어있던 GDI 오브젝트 핸들러
*/
HGDIOBJ SelectObject(HDC hdc, HGDIOBJ h);
```



##### DeleteObject()

- 생성된 GDI 오브젝트를 삭제한다.
- 삭제하지 않으면 컴퓨터의 자원을 계속 점유하므로 메모리 누수가 발생한다.
- DC에 선택되어 현재 사용중인 GDI는 삭제되지 않으므로 다른 GDI를 선택시키고 삭제해야한다. 
- SelectObject()의 반환값이 이전 GDI이기 때문에 이 값을 저장했다가 새로 생성하여 선택시킨 GDI를 삭제하기 전에 이전 GDI를 선택시키고 선택 해제된 GDI를 삭제하는 방식으로 사용한다.

```cpp
/*
HGDIOBJ ho : 삭제할 GDI 오브젝트 핸들러
return : 0 - 현재 선택됐거나 유효하지 않은 GDI 핸들, 0 이외 - 삭제 성공
*/
BOOL DeleteObject(HGDIOBJ ho);
```



###### todo - 현재 선택된 펜 핸들을 삭제해도 1이 리턴되는 이유는?

```cpp
// Pen 생성
HPEN hPen = CreatePen(PS_DASHDOT, 1, RGB(255, 0, 0));
// DC에 펜 지정
HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);
MoveToEx(hdc, 100, 100, NULL);
LineTo(hdc, 150, 150);

//SelectObject(hdc, hOldPen);
BOOL bDeletePenResult = DeleteObject(hPen); // 1이 리턴된다.
```





##### GDI 오브젝트 사용 절차

1. 핸들 선언
   - HPEN hPen, ...
2. GDI 오브젝트 생성
   - CreatePen(), ...
3. 생성된 GDI 오브젝트를 DC에 선택, 이때 이전 핸들을 저장
   - SelectObject()
4. 사용
   - Rectangle(), Ellipse(), MoveToEx(), LineTo(), ...
5. 선택을 해제, 이때 저장된 이전 핸들을 선택되도록 한다.
   - SelectObject()
6. 생성된 GDI 오브젝트를 삭제
   - DeleteObject()



#### GDI 오브젝트 종류

##### 펜(Pen)

- 선을 그을 때 사용되는 GDI 오브젝트



###### 펜 생성

```cpp
/*
int iStyle : 선의 모양 정의(PS_SOLID, PS_DASH, PS_DASHDOT...)
int nWidth : 선 굵기, 디폴트 1, 0일 경우 1로 지정됨
COLORREF color : 선 색상
*/
HPEN CreatePen(int iStyle, int nWidth, COLORREF color);
```



###### 선 그리기

```cpp
// DC에 펜 지정
HPEN hOldPen = (HPEN)SelectObject(hdc, hPen);
MoveToEx(hdc, 100, 100, NULL);
LineTo(hdc, 200, 100);
```



###### 사각형 그리기

```cpp
Rectangle(hdc, 200, 100, 250, 150);
```



원 그리기

```cpp
Ellipse(hdc, 250, 150, 300, 200);
```



##### 브러시(Brush)

- 도형의 내부를 색상과 패턴으로 채우는 역할



###### 브러시 생성

``` cpp
HBRUSH CreateSolidBrush(COLORREF color);
// CreateHatchBrush, CreatePatternBrush, CreateBrushIndirect, CreateDIBPatternBrushPt
```



##### 비트맵

###### 이미지 종류

- bmp, jpg, gif, tga



###### 이미지를 다루는 두 가지 방법

1. 비트맵을 리소스에 등록하여 사용
2. LoadImage() 함수를 이용하여 파일로부터 읽어 사용



###### 비트맵 사용법

```cpp
// ========== Bitmap ==========
// 비트맵 헤더
BITMAP resBitmapHeader; // 리소스 비트맵 헤더
BITMAP fileBitmapHeader; // 파일 비트맵 헤더

// 리소스에 등록된 비트맵 불러오기
HBITMAP hResBitmap = LoadBitmap(g_hInstance, MAKEINTRESOURCE(IDB_BITMAP1));

// 파일의 비트맵 불러오기, 파일은 프로젝트 폴더가 기준이다.(프로젝트 폴더 밖의 Debug 폴더에 넣지 않는다)
// 마지막 파라미터를 LR_LOADFROMFILE로 지정해야한다.
HBITMAP hFileBitmap = (HBITMAP)LoadImage(NULL, TEXT("zzal.bmp"), IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);

// 비트맵 헤더를 읽어들임
GetObject(hResBitmap, sizeof(BITMAP), &resBitmapHeader);
GetObject(hFileBitmap, sizeof(BITMAP), &fileBitmapHeader);

// Memory DC 생성
HDC hResMemDC = CreateCompatibleDC(hdc);
HDC hFileMemDC = CreateCompatibleDC(hdc);

// Memory DC에 비트맵 선택
SelectObject(hResMemDC, hResBitmap);
SelectObject(hFileMemDC, hFileBitmap);

// Memory DC를 화면 DC에 복사
BitBlt(hdc, 300, 300, resBitmapHeader.bmWidth, resBitmapHeader.bmHeight, hResMemDC, 0, 0, SRCCOPY);
BitBlt(hdc, 300 + resBitmapHeader.bmWidth, 300, fileBitmapHeader.bmWidth, fileBitmapHeader.bmHeight, hFileMemDC, 0, 0, SRCCOPY);

// 생성했던 비트맵과 Memory DC를 제거
DeleteObject(hResBitmap);
DeleteObject(hFileBitmap);
DeleteDC(hResMemDC);
DeleteDC(hFileMemDC);
// ========== Bitmap ========== end
```



###### LoadBitmap()

- 리소스에 있는 비트맵을 읽어온다

```cpp
/*
HINSTANCE hInstance : 인스턴스 핸들
LPCSTR lpBitmapName : 리소스 비트맵 이름(MAKEINTRESOURCE를 이용한다)
*/
HBITMAP LoadBitmap(HINSTANCE hInstance, LPCSTR lpBitmapName);
```



###### LoadImage()

- icon, cursor, animated cursor, bitmap 등을 로드한다.
- LoadIcon, LoadCursor, LoadBitmap의 모든 기능을 가지며 추가 기능도 같는다.
- 이미지를 파일에서 읽고 DIB 색션으로 읽을 수 있다.

```cpp
/*
HINSTANCE hIns : 인스턴스 핸들
LPCSTR name : 파일 이름(경로)
UINT type : 이미지 타입 - IMAGE_BITMAP, IMAGE_CURSOR, IMAGE_ICON
int cx : 아래에서 설명
int cy : 상동
UINT fuLoad : 이미지를 읽어올 방법
*/
HANDLE LoadImage(HINSTANCE hIns, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad);
```



- 파라미터 설명 추가
  - cx, cy
    - 아이콘과 커서를 읽을 경우 리소스에 있는 이미지 중 어떤 크기의 이미지를 읽을 것인가를 지정
    - 이 값이 0이고 fuLoad에 LR_DEFAULTSIZE 플래그가 지정되어있으면 시스템 매트릭스에 정의되어 있는 SM_CXICON, SM_CXCURSOR의 크기 이미지를 읽는다.
    - 이 값이 0이고 fuLoad에 LR_DEFAULTSIZE 플래그가 지정되어있지 않으면 리소스의 실제 크기로 읽는다.
  - fuLoad
    - LR_LOADFROMFILE
      - LPCSTR name 인수를 리소스 이름 대신 파일명으로 인식하여 파일에서 리소스를 읽어온다.



###### DDB & DIB

- DDB(Device Dependent Bitmap)
  - Win3.0 이전에 사용하던 방식
  - 이미지에 대한 기본 정보만 가지므로 많은 제약을 가지고 있다.
  - 하위 호환성 때문에 아직도 사용됨
- DIB
  - DDB보다 더 많은 정보(색상 테이블, 해상도 등)를 가진다.
  - 장치 독립적이다.
  - .bmp 파일은 모두 DIB 포맷이다.
  - DC의 색상 포맷이 고정되어 있어서 DIB는 DC에 직접 선택될수 없기 때무에 DDB로 교체되어야 한다.



###### DIB Section

- DIB를 DC에 사용하기 위해 DDB로 변환을 최초 한번만 하고 사용하기 위한 포맷
- DIB 포맷의 형태를 갖추었으므로 장치 독립적이고 DDB 포맷과 호환되므로 BitBlt, TransparentBlt로 출력이 가능하다.



###### GetObject()

- GDI 오브젝트에 대한 정보를 구한다.
- GDI 오브젝트에 따라 적절한 헤더 정보를 기록할 구조체 변수를 생성하고 크기와 함께 포인터를 넘기면 핸들로 전달된 GDI 오브젝트에서 헤더 정보를 읽어 구조체에 기록한다.

```cpp
/*
HANDLE h : GDI 오브젝트의 핸들
int c : pv로 전달될 데이터 타입의 크기
LPVOID pv : 읽은 데이터를 기록할 버퍼
*/
int GetObject(HANDLE h, int c, LPVOID pv)
```



###### 메모리 DC

- 화면 DC와 동일한 특성을 가지며 그 내부에 출력 표면을 가진 메모리 영역이다.
- 비트맵은 크기가 큰 데이터이기 때문에 바로 화면에 그리면 사용자가 중간과정을 보게되어 사용성에 좋지 않은 영향을 미친다.
- 따라서 비트맵 그리기가 완료된 후 실제 화면에 출력하기 위해 화면 DC와 동일하게 화면을 구성할 수 있는 기능 메모리 DC에 비트맵을 그리고 완료 후 화면 DC에 복사해준다.
- CreateCompatibleDC() 함수로 생성한다.

```cpp
/*
HDC hdc : 복사 원본이 될 DC
return : 복사된 DC
*/
HDC CreateCompatibleDC(HDC hdc)
```



###### BitBlt()

- bit-block transfer
- DC간에 고속 복사를 수행

```cpp
/*
HDC hdc : 비트맵이 복사될 DC
int x : 비트맵이 복사될 좌표
int y : 비트맵이 복사될 좌표
int cx : 비트맵이 복사될 넓이
int cy : 비트맵이 복사될 높이
HDC hdcSrc : 복사될 비트맵을 가지고 있는 DC
int x1 : 복사될 비트맵의 좌측 좌표
int y1 : 복사될 비트맵의 상단 좌표
DWORD rop : raster-operation code. 브러쉬와 복사원, 복사처의 비트맵 색상이 논리 연산될 방법을 지정
*/
BOOL BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
```



###### DeleteDC()

- DC를 삭제한다.
- 새로운 DC를 생성해서 사용한 경우 DeleteDC를 호출한다.

```cpp
/*
HDC hdc : 삭제할 DC
return : 삭제 성공 여부
*/
BOOL DeleteDC(HDC hdc);
```



###### StretchBlt()

- 비트맵을 확대/축소하여 복사할 수 있다.



###### TransparentBlt()

- 비트맵을 확대/축소하여 복사할 수 있다.
- 지정한 색상을 제외하고 출력할 수 있다.
- msimg32.lib 라이브러리를 링크 시켜줘야한다.
  - 프로젝트 속성 > 링커 > 입력 > 추가 종속성에 추가한다.

```cpp
TransparentBlt(hdc, 300 + resBitmapHeader.bmWidth, 300, fileBitmapHeader.bmWidth, fileBitmapHeader.bmHeight, hFileMemDC, 0, 0, fileBitmapHeader.bmWidth, fileBitmapHeader.bmHeight, RGB(231, 223, 220));
```





### 색상 매크로 함수

#### RGB()

- 개별 r, g, b 값을 받아서 COLORREF(DWORD) 데이터 타입에 저장하여 반환한다.

```cpp
COLORREF RGB(BYTE r, BYTE g, BYTE b);
```



##### COLORREF 구조체

- R, G, B 색상값을 저장하는 데이터 형식
- 상위 8비트는 쓰이지 않으며 하위 비트에서부터 R, G, B 값이 저장되므로 다음과 메모리 구조에서는 B, G, R 순서로 저장된다.

```cpp
// COLORREF를 만드는 매크로 함수 
#define RGB(r,g,b) ((COLORREF)(((BYTE)(r)|((WORD)((BYTE)(g))<<8))|(((DWORD)(BYTE)(b))<<16)))
```



#### GetRValue(), GetGValue(), GetBValue()

- 채널별 색상을 BYTE로 반환한다.

```cpp
BYTE GetRValue(DWORD rgb);

BYTE r = GetRValue(color);
```



#### SetPixel

- 특정 픽셀에 색상 출력

```cpp
COLORREF SetPixel(HDC hdc, int x, int y, COLORREF color);

SetPixel(hdc, 150, 150, RGB(255, 0, 0));
```



#### GetPixel

- 특정 픽셀의 색상 가져오기

```cpp
COLORREF GetPixel(HDC hdc, int x, int y);

COLORREF color1 = GetPixel(hdc, 150, 150);
```



#### SetTextColor

- 출력할 문자열 색상 설정 함수

```cpp
COLORREF SetTextColor(HDC hdc, COLORREF color);

SetTextColor(hdc, RGB(255, 0, 0));
```



#### SetBkColor

- 글자의 배경 색상 설정

```cpp
COLORREF SetBkColor(HDC hdc, COLORREF color);

SetBkColor(hdc, RGB(0, 255, 255));
```





### InvalidateRect()

- 화면의 일부 또는 전체를 무효화해서 다시 그릴(업데이트) 때 사용
- WM_PAINT 메시지를 발생 시킨다

```cpp
/*
HWND hWnd : 무효화 대상이 되는 윈도우, NULL일 경우 전체 윈도우
RECT *lpRect : 무효화 영역, NULL(0)일 경우 전체 영역
BOOL bErase : TRUE : 지우고 다시 그림, FALSE : 지우지 않고 겹쳐그림
*/
BOOL InvalidateRect(HWND hWnd, RECT *lpRect, BOOL bErase);
```



#### 무효영역

- 화면의 일부 또는 전체가 변경되어 다시 그려야할 필요가 있는 영역
- 무효영역이 있을 경우 OS는 응용 프로그램에 WM_PAINT 메시지를 보내 다시 그리도록 한다.
- 응용 프로그램에서 화면을 변경시켰을 경우 InvalidateRect() 함수를 이용하여 강제로 무효화시킬 수 있다.





## 입력

### 키보드

#### WM_CHAR

- 문자 입력시 발생하는 메시지
- 입력된 문자의 아스키 코드는 wParam으로 전달
- lParam으로는 반복 횟수, 스캔 코드, 확장키, 이전키 상태 플래그 등의 정보가 들어있다.

```cpp
case WM_CHAR:
{
    g_str[g_strIndex++] = wParam;
    InvalidateRect(NULL, NULL, TRUE);
}
```



#### WM_KEYDOWN

- 문자 이외의 키를 입력받을 수 있다.
- wParam에 문자 코드 대신 <u>가상 키코드</u>가 들어있다.
- <u>가상 키코드</u>
  - 키보드의 종류에 상관없이 카를 입력받기 위한 코드값
  - 현재 키보드에 없는 키값도 미리 정의되어있다.
    - VK_SELECT, VK_EXECUTE, VK_HELP
    - ~ F16
    - 윈도우를 다른 시스템에 이식하더라도 키 코드를 사용할 수 있게 하기 위함
- 숫자 및 영문자의 가상 키코드는 아스키 코드와 같다
- lParam으로 전달되는 값은 WM_CHAR와 동일

```cpp
case WM_KEYDOWN:
{
	switch (wParam)
	{
	case VK_LEFT:
		g_movableTextPosition.x -= 1;
		break;
	case VK_RIGHT:
		g_movableTextPosition.x += 1;
		break;
	case VK_UP:
		g_movableTextPosition.y -= 1;
		break;
	case VK_DOWN:
		g_movableTextPosition.y += 1;
		break;
	default:
		break;
	}

	InvalidateRect(hWnd, NULL, TRUE);
}
```



#### WM_KEYUP

- 키가 떨어질 때 발생
- wParam, lParam의 의미는 WM_KEYDOWN과 동일



#### GetAsyncKeyState()

- 실시간으로 키 입력을 체크
- 메시지 큐에 저장되는 키 메시지의 단점을 보완
- 리턴값
  - 키 눌림이 있으면 최상위 비트(MSB)가 1.
  - Caps Lock, Scroll Lock 같은 토글키가 On 상태이면 최하위 비트(LSB)가 1.



##### GetAsyncKeyState() 리턴값

? 아래 테이블 검증

| 값     | 설명                                                   |
| ------ | ------------------------------------------------------ |
| 0x0000 | 이전에 누른 적이 없고 호출 시점에도 눌려있지 않은 상태 |
| 0x0001 | 이전에 누른 적이 있고 호출 시점에는 눌려있지 않은 상태 |
| 0x8000 | 이전에 누른 적이 없고 호출 시점에는 눌려있는 상태      |
| 0x8001 | 이전에 누른 적이 있고 호출 시점에도 눌려있는 상태      |



```cpp
if (GetAsyncKeyState(VK_F1) & 0x8000) {
	g_bF1KeyDown = TRUE;
}
else {
	g_bF1KeyDown = FALSE;
}
```



### 마우스

#### WM_MOUSEMOVE

- 마우스 이동 시 발생
- 마우스 좌표는 lParam으로 전달
  - LOWORD(lParam) : x좌표
  - HIWORD(lParam) : y좌표
- 현재 눌린 키에 대한 정보는 wParam을 다음의 매크로와 비교
  - MK_LBUTTON, MK_RBUTTON, MK_SHIFT, ...

```cpp
// 드래그하여 사각형 그리기 방법 1.
if (g_bDragging) { // WM_LBUTTONDOWN에서 TRUE로 만든다.
	WORD x = LOWORD(lParam);
	WORD y = HIWORD(lParam);
	HDC hdc = GetDC(hWnd);
	Rectangle(hdc, g_dragStartPosition.x, g_dragStartPosition.y, x, y);
	ReleaseDC(hWnd, hdc);
}

// 드래그하여 사각형 그리기 방법 2.
if (wParam == MK_LBUTTON) {
	WORD x = LOWORD(lParam);
	WORD y = HIWORD(lParam);
	HDC hdc = GetDC(hWnd);
	Rectangle(hdc, g_dragStartPosition.x, g_dragStartPosition.y, x, y);
	ReleaseDC(hWnd, hdc);
}
```



### 타이머

- WM_TIMER 메시지를 지정한 시간 간격마다 발생시킨다.
- 여러개의 타이머를 설정할 수 있고 각 타이머는 아이디로 구분한다.
- wParam가 타이머의 아이디값이다.
- KillTimer() 함수로 타이머를 종료시킨다.

```cpp
	case WM_CREATE: // 윈도우가 처음 생성됐을 때 발생
		SetTimer(hWnd, 1, 1000, NULL);
		SetTimer(hWnd, 2, 2000, NULL);
		break;

	case WM_TIMER:
	{
		switch (wParam)
		{
		case 1:
			g_nTimerCount1++;
			break;

		case 2:
			g_nTimerCount2++;
			break;

		default:
			break;
		}
		InvalidateRect(hWnd, NULL, false);
	}
	break;

	case WM_DESTROY:
		KillTimer(1);
		KillTimer(2);
		PostQuitMessage(0); // GetMessage() 함수가 0을 반환하게 된다.
	break;
```



#### 타이머 콜백함수

- WM_TIMER 메시지 대신 지정한 콜백함수가 호출된다.

```cpp
SetTimer(hWnd, 2, 2000, TimerProc);

VOID CALLBACK TimerProc(HWND hWnd, UINT message, UINT_PTR id, DWORD time) {
	g_nTimerCount2++;
}
```





## 다이얼로그

- 부모 윈도우와 개별적으로 생성되어 사용자로부터 정보를 입력 받는 창
- 형태
  - 모달
    - 
  - 모달리스
    - 



### 모달(Modal)과 모델리스(Modeless) 다이얼로그

#### 모달 다이얼로그

- 다이얼로그가 열린 상태에서는 다이얼로그 이외의 윈도우를 조작할 수 없다
- DialogBox() 함수로 생성하며 다이얼로그가 닫힐 때까지 리턴하지 않는다.



#### 모델리스(Modeless) 다이얼로그

- 다이얼로그가 열려 있어도 다른 윈도우를 조작할 수 있다.
- CreateDialog() 함수로 생성하며 즉시 다이얼로그 핸들을 반환한다.



### 다이얼로그 생성/종료

- 리소스
  - 리소스 추가 > 다이얼로그



```cpp
// 다이얼로그 생성
/*
HINSTANCE hInstance : 응용프로그램의 인스턴스 핸들러
LPCSTR lpTemplateName : 리소스 아이디 문자열
HWND hWndParent : 다이얼로그의 부모 윈도우 핸들러
DLGPROC lpDialogFunc : 다이얼로그 프로시저
LPARAM dwInitParam : 다이얼로그 초기화 인자값
*/
INT_PTR DialogBox(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);

// 예 - 다이얼로그 생성
DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_DIALOG1), hWnd, DialogProc);

// 다이얼로그 종료
/*
HWND hDlg : 다이얼로그 윈도우 핸들러
INT_PTR nResult : DialogBox() 함수의 리턴값
*/
BOOL EndDialog(HWND hDlg, INT_PTR nResult);

// 예 - 다이얼로그 종료
EndDialog(hWnd, 0);
```





### 다이얼로그 프로시저

- 다이얼로그에서 발생하는 메시지를 처리하기 위한 함수
- 메시지를 제대로 처리했으면 TRUE, 처리하지 못했으면 FALSE를 리턴한다.
- FALSE를 리턴 시 이 메시지의 처리는 OS가 해준다.
  - 따라서 DefWindowProc을 호출할 필요가 없다.
- WndProc과 다르게 WM_CREATE 메시지 대신 WM_INITDIALOG 메시지를 받는다.
  - 이 메시지를 받고 TRUE를 리턴하면 초기화가 완료된다.
- WM_COMMAND 메시지를 주로 처리
  - LOWORD(wParam) : 메시지를 보낸 컨트롤러의 ID
  - HIWORD(wParam) : 통지 코드



```cpp
INT_PTR CALLBACK DialogProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_INITDIALOG:
		return true;

	case WM_COMMAND:
		switch (wParam)
		{
		case IDOK:
		case IDCANCEL:
			EndDialog(hWnd, 0);
			return TRUE;
		default:
			break;
		}
	default:
		return FALSE;
		break;
	}
	return FALSE;
}
```



### 모달 다이얼로그로 데이터 변경하기

```cpp
// 다이얼로그 박스 생성
// DialogBox의 반환값을 보고 성공/취소를 판단하여 처리한다.
// 반환값을 EndDialog의 두번째 파라미터로 넘기는 값이 반환된다.
if (DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_DIALOG1), hWnd, DialogProc) != 0) {
	InvalidateRect(hWnd, NULL, TRUE);
};

// 다이얼로그 프로시저
INT_PTR CALLBACK DialogProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_INITDIALOG:
		// 다이얼로그 초기화 시 각 컨트롤러에 초기값을 넣어준다.
		SetDlgItemInt(hWnd, IDC_X, g_nDialogX, FALSE);
		SetDlgItemInt(hWnd, IDC_Y, g_nDialogY, FALSE);
		SetDlgItemText(hWnd, IDC_STR, g_szDialogStr);
		return true;

	case WM_COMMAND:
		switch (wParam)
		{
		case IDOK:
			// 작업이 끝나고 다이얼로그창을 성공적으로 닫을 때 컨트롤러에 있는 값을 넣어준다.
			g_nDialogX = GetDlgItemInt(hWnd, IDC_X, NULL, FALSE);
			g_nDialogY = GetDlgItemInt(hWnd, IDC_Y, NULL, FALSE);
			GetDlgItemText(hWnd, IDC_STR, g_szDialogStr, 100);
			EndDialog(hWnd, 1); // DialogBox()의 리턴값이 1이 된다.
			break;
		case IDCANCEL:
			// 다이얼로그 작업을 취소할 경우 그대로 나간다.
			EndDialog(hWnd, FALSE); // DialogBox()의 리턴값이 0이 된다.
			return TRUE;
		default:
			break;
		}
	default:
		return FALSE;
		break;
	}
	return FALSE;
}
```



### 모델리스 다이얼로그로 데이터 변경하기

```CPP
// 모델리스 다이얼로그 생성
// IsWindow() 함수로 현재 유효한 윈도우 핸들인지 확인한다.
if (IsWindow(g_hModelessDialog) == FALSE) {
	// CreateDialog()는 생성한 다이얼로그의 핸들을 바로 반환한다.
	g_hModelessDialog = CreateDialog(g_hInstance, MAKEINTRESOURCE(IDD_DIALOG2), hWnd, DialogProc_Modeless);

	// 다이얼로그를 생성했지만 아직 보이지 않기 때문에 화면에 보이도록 한다.
	// 디얼로그에 WS_VISIBLE 스타일을 주었다면 
	// ShowWindow() 함수를 호출하지 않아도 되지만
	// 디폴트가 WS_VISIBLE 스타일이 아니므로 호출한다.
	ShowWindow(g_hModelessDialog, SW_SHOW);
}

// 모델리스 다이얼로그 프로시저
INT_PTR CALLBACK DialogProc_Modeless(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	switch (message)
	{
	case WM_INITDIALOG:
		SetDlgItemInt(hWnd, IDC_X, g_nDialogX, FALSE);
		SetDlgItemInt(hWnd, IDC_Y, g_nDialogY, FALSE);
		SetDlgItemText(hWnd, IDC_STR, g_szDialogStr);
		return true;

	case WM_COMMAND:
		switch (wParam)
		{
		case ID_CHANGE:
			g_nDialogX = GetDlgItemInt(hWnd, IDC_X, NULL, FALSE);
			g_nDialogY = GetDlgItemInt(hWnd, IDC_Y, NULL, FALSE);
			GetDlgItemText(hWnd, IDC_STR, g_szDialogStr, 100);
			InvalidateRect(g_hMainWnd, NULL, TRUE); // 데이터 변경을 메인윈도우의 화면에 반영
			break;
		case ID_CLOSE:
			DestroyWindow(g_hModelessDialog); // CreateDialog()로 열었으므로 DestroyWindow()로 닫는다.
			//EndDialog(hWnd, FALSE); // 닫히긴하지만 다시 열리지 않는다.
			return TRUE;
		default:
			break;
		}
	default:
		return FALSE;
		break;
	}
	return FALSE;
}
```









## 에러 해결

### 빌드 시 "_main 외부 기호(참조 위치: "int __cdecl invoke_main(void)" (?invoke_main@@YAHXZ) 함수)에서 확인하지 못했습니다." 뜨는 경우

- 프로젝트 설정 > 링커 > 시스템 > 하위 시스템 > 설정 안함
  - 콘솔 프로그래밍 시 콘솔창이 바로 꺼지지 않게 '콘솔'로 설정한 경우 Win32 프로그래밍에서는 문제가 된다.



### 리소스 뷰에서 "다른 편집기에서 열려 있습니다" 뜨는 경우

- 원인
  - 리소스를 편집하면 VS가 자동으로 resource.h 파일에 해당 리소스의 아이디 등을 기록하는데 열려 있거나 다른 파일에서 사용중이면 충돌할 수 있기 때문에 resource.h 파일은 동시에 편집할 수 없다.
- 해결
  - resource.h 파일이 열려있으면 닫아주면 된다.



### 프로그램 실행 시  마우스 커서가 모래시계로 나오는 경우

- 원인
  - 모르겠다.
- 해결
  - 마우스 이동 시 발생하는 WM_SETCURSOR 메시지에서 SetCursor를 해주는 것으로 일단 해결
    - 이렇게 해결하면 클라이언트 영역뿐만 아니라 윈도우 전 영역에 걸쳐 내가 지정한 커서가 나오게 된다.



### 메뉴 생성 후 IDR_MENU1 매크로를 찾을 수 없다는 VS의 경고. 컴파일, 실행은 잘됨

- 원인
  - 모르겠다.
- 해결
  - 다음날 하니 잘 됨...



### Run-Time Check Failure #2 - Stack around the variable '변수 이름' was corrupted. 에러

- 원인
  - 스택에 저장된 변수의 포인터를 이용하여 변수의 크기보다 더 큰 값을 저장한 경우 스택이 깨져서 발생되는 버그
- 해결
  - 데이터 형을 정확히 지정해준다.
- 사례
  - _stprintf_s 사용 시 버퍼의 길이를 실제 길이 보다 더 큰 값을 준경우



# 영어 단어

-  work out
  - 되다. 운동하다. 만들어내다. 해결하다. 이끌어내다.
-  caption
   -  표제, 자막, 타이틀
-  stock
   -  재고, 저장, 비축, 주식
-  indirect
   -  간접적인



# 참고

- 나우캠퍼스 - Win32 API 윈도우 프로그래밍
  -  <https://www.youtube.com/playlist?list=PLOKPEzlY4JKTFx1udqQRdYb1ydob9V5u3>
- Window Styles
  -  <https://docs.microsoft.com/en-us/windows/desktop/winmsg/window-styles>
- Window Class Styles
  - <https://docs.microsoft.com/en-us/windows/desktop/winmsg/window-class-styles>
- Coding Style Conventions
  - <https://docs.microsoft.com/en-us/windows/desktop/stg/coding-style-conventions>
- LoadIconA function
  - <https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-loadicona>
- LoadCursorA function
  - <https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-loadcursora>
- UCRT alphabetical function reference
  - <https://docs.microsoft.com/en-us/cpp/c-runtime-library/reference/crt-alphabetical-function-reference?view=vs-2019>
  - UCRT
    - Universal C Runtime
- Window Class에 대하여~
  - <https://m.blog.naver.com/PostView.nhn?blogId=tipsware&logNo=221004018862&proxyReferer=https%3A%2F%2Fwww.google.com%2F>
- 링크 에러 해결
  - <https://pang2h.tistory.com/156>
- 리소스 뷰 "다른 편집기에서 열려 있습니다' 에러 해결
  - <https://blog.naver.com/PostView.nhn?blogId=tipsware&logNo=221307958643&categoryNo=85&parentCategoryNo=0&viewDate=¤tPage=1&postListTopCurrentPage=1&from=postView&userTopListOpen=true&userTopListCount=10&userTopListManageOpen=false&userTopListCurrentPage=1>
- 핵심 API로 배우는 윈도우 프로그래밍
- API 입문 강좌
  - <http://soen.kr/lecture/win32api/win32lec.htm>
- 비트맵 직접제어(DIB Section)
  - <https://m.blog.naver.com/PostView.nhn?blogId=since860321&logNo=130169663515&proxyReferer=https%3A%2F%2Fwww.google.com%2F>
- API 비트맵 DIB에 대해서
  - <http://blog.naver.com/PostView.nhn?blogId=kain3583&logNo=70123205111&parentCategoryNo=&categoryNo=23&viewDate=&isShowPopularPosts=true&from=search>
- GetAsyncKeyState 함수
  - <https://m.blog.naver.com/power2845/50143021565>

